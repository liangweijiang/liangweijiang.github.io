{"meta":{"title":"Hexo","subtitle":"","description":"","author":"liangweijiang","url":"https://liangweijiang.github.io","root":"/"},"pages":[{"title":"categories","date":"2020-02-19T09:53:30.000Z","updated":"2020-02-19T09:54:44.015Z","comments":true,"path":"categories/index.html","permalink":"https://liangweijiang.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-02-19T10:00:45.000Z","updated":"2020-02-19T10:01:19.886Z","comments":true,"path":"tags/index.html","permalink":"https://liangweijiang.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"DRF源码解析2--viewsets.ModelViewSet对视图的封装","slug":"DRF-02","date":"2020-02-19T13:47:47.427Z","updated":"2020-02-19T13:49:32.438Z","comments":true,"path":"2020/02/19/DRF-02/","link":"","permalink":"https://liangweijiang.github.io/2020/02/19/DRF-02/","excerpt":"","text":"viewsetsdef中 viewsets 对 view 进行了更加深层的封装,在CBV编程中减少代码的冗余,截取viewsets源码如下 12345678class ModelViewSet(mixins.CreateModelMixin, mixins.RetrieveModelMixin, mixins.UpdateModelMixin, mixins.DestroyModelMixin, mixins.ListModelMixin, GenericViewSet):# 可以看到viewsets中的ModelViewSet只是继承了各种类,每一个类对应CBV的每一个方法,如CreateModelMixin则对应post方法 pass 进入GenericViewSet的源码中,不难发现,GenericViewSet这个类主要是获取我们的数据和处理数据的组件 123class GenericViewSet(ViewSetMixin, generics.GenericAPIView): # GenericViewSet同样是继承了两个类 pass 进入generics.GenericAPIView 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657class GenericAPIView(views.APIView): # queryset就是获取的ORM对象 queryset = None # serializer_class是序列化的类 serializer_class = None lookup_field = 'pk' lookup_url_kwarg = None # The filter backend classes to use for queryset filtering filter_backends = api_settings.DEFAULT_FILTER_BACKENDS # The style to use for queryset pagination. # pagination_class就是和分页组件相关的类,默认为drf配置中的组件 pagination_class = api_settings.DEFAULT_PAGINATION_CLASS def get_queryset(self): # 这里断言就是为了说明在继承这个类时,一定要有queryset属性或覆盖这个方法 assert self.queryset is not None, ( \"'%s' should either include a `queryset` attribute, \" \"or override the `get_queryset()` method.\" % self.__class__.__name__ ) # 获取ORM对象 queryset = self.queryset if isinstance(queryset, QuerySet): # Ensure queryset is re-evaluated on each request. queryset = queryset.all() return queryset def get_serializer(self, *args, **kwargs): serializer_class = self.get_serializer_class() kwargs['context'] = self.get_serializer_context() # serializer_class接收的参数可能不同 return serializer_class(*args, **kwargs) def get_serializer_class(self): # 继承这个类时,一定要有serializer_classt属性或覆盖这个方法 assert self.serializer_class is not None, ( \"'%s' should either include a `serializer_class` attribute, \" \"or override the `get_serializer_class()` method.\" % self.__class__.__name__ ) return self.serializer_class def get_serializer_context(self): return &#123; 'request': self.request, 'format': self.format_kwarg, 'view': self &#125; def filter_queryset(self, queryset): for backend in list(self.filter_backends): queryset = backend().filter_queryset(self.request, queryset, self) return queryset 接着回到ModelViewSet中,进入到mixins.CreateModelMixin的源码中 1234567891011121314151617181920class CreateModelMixin: \"\"\" Create a model instance. \"\"\" def create(self, request, *args, **kwargs): # 这里调用的就是GenericAPIView中的get_serializer serializer = self.get_serializer(data=request.data) serializer.is_valid(raise_exception=True) self.perform_create(serializer) headers = self.get_success_headers(serializer.data) return Response(serializer.data, status=status.HTTP_201_CREATED, headers=headers) def perform_create(self, serializer): serializer.save() def get_success_headers(self, data): try: return &#123;'Location': str(data[api_settings.URL_FIELD_NAME])&#125; except (TypeError, KeyError): return &#123;&#125; 现在我们只需要继承ModelViewSet,然后重写queryset和处理数据所需要的组件类如序列化的类等,但是怎么将self.post对应上self.list方法呢,GenericViewSet还继承了ViewSetMixin,看一下ViewSetMixin的源码的截取 1234567891011121314151617181920212223242526272829303132333435class ViewSetMixin: @classonlymethod # 对as_view()方法又一次封装,action表示可以接收参数了 def as_view(cls, actions=None, **initkwargs): if not actions: raise TypeError(\"The `actions` argument must be provided when \" \"calling `.as_view()` on a ViewSet. For example \" \"`.as_view(&#123;'get': 'list'&#125;)`\") def view(request, *args, **kwargs): self = cls(**initkwargs) # We also store the mapping of request methods to actions, # so that we can later set the action attribute. # eg. `self.action = 'list'` on an incoming GET request. self.action_map = actions # Bind methods to actions # This is the bit that's different to a standard view # method, action退出action为一个字典,&#123;'get':'list'&#125; for method, action in actions.items(): # handler为实例中的各个方法 handler = getattr(self, action) # 这里setattr相当于metmod == handler setattr(self, method, handler) if hasattr(self, 'get') and not hasattr(self, 'head'): self.head = self.get self.request = request self.args = args self.kwargs = kwargs # And continue as usual return self.dispatch(request, *args, **kwargs) return csrf_exempt(view) 奉献一张图来看下我们的继承顺序","categories":[{"name":"django-rest-framework","slug":"django-rest-framework","permalink":"https://liangweijiang.github.io/categories/django-rest-framework/"}],"tags":[{"name":"DRF","slug":"DRF","permalink":"https://liangweijiang.github.io/tags/DRF/"}]},{"title":"DRF源码解析1--APIView对request的重新封装","slug":"DRF-01","date":"2020-02-19T08:58:37.586Z","updated":"2020-02-19T10:08:43.094Z","comments":true,"path":"2020/02/19/DRF-01/","link":"","permalink":"https://liangweijiang.github.io/2020/02/19/DRF-01/","excerpt":"","text":"截取APIView12345678910111213141516171819202122232425262728293031323334353637383940414243444546@classmethodclass APIView(View): def as_view(cls, **initkwargs): if isinstance(getattr(cls, 'queryset', None), models.query.QuerySet): def force_evaluation(): raise RuntimeError( 'Do not evaluate the `.queryset` attribute directly, ' 'as the result will be cached and reused between requests. ' 'Use `.all()` or call `.get_queryset()` instead.' ) cls.queryset._fetch_all = force_evaluation # 继承了django中View类的的as_view()方法,然后重写了dispatch方法 view = super().as_view(**initkwargs) view.cls = cls view.initkwargs = initkwargs return csrf_exempt(view) def dispatch(self, request, *args, **kwargs): self.args = args self.kwargs = kwargs # 在传入request是,apiview对request进行了一次包装 request = self.initialize_request(request, *args, **kwargs) # 此时self.request是initialize_request方法返回的Request self.request = request self.headers = self.default_response_headers # deprecate? try: # 相比于View类的dispatch方法,Apiview在这里进行了一次初始化的方法 self.initial(request, *args, **kwargs) # Get the appropriate handler method if request.method.lower() in self.http_method_names: handler = getattr(self, request.method.lower(), self.http_method_not_allowed) else: handler = self.http_method_not_allowed response = handler(request, *args, **kwargs) except Exception as exc: response = self.handle_exception(exc) self.response = self.finalize_response(request, response, *args, **kwargs) return self.response 进入self.initalize_request()12345678910def initialize_request(self, request, *args, **kwargs): parser_context = self.get_parser_context(request) # 可以看到, request已经被封装成Request返回,而request则被封装成Request的一个属性 return Request( request, parsers=self.get_parsers(), authenticators=self.get_authenticators(), negotiator=self.get_content_negotiator(), parser_context=parser_context ) 截取Ruquest123456789101112131415161718192021222324252627282930class Request: def __init__(self, request, parsers=None, authenticators=None, negotiator=None, parser_context=None): assert isinstance(request, HttpRequest), ( 'The `request` argument must be an instance of ' '`django.http.HttpRequest`, not `&#123;&#125;.&#123;&#125;`.' .format(request.__class__.__module__, request.__class__.__name__) ) # request被封装了私有属性 self._request = request @property def content_type(self): meta = self._request.META # 封装了content_type方法获取传输类型 return meta.get('CONTENT_TYPE', meta.get('HTTP_CONTENT_TYPE', '')) @property def query_params(self): \"\"\" More semantically correct name for request.GET. \"\"\" # django的view中的request.Get属性封装成了query_params属性 return self._request.GET @property def data(self): if not _hasattr(self, '_full_data'): self._load_data_and_files() # django的view中的request.Post属性封装成了data属性 return self._full_data 我们可以看出~CBV在内部做了一个分发,本质和FBV是一样的。 以后做接口开发的时候，就要用CBV，学习了restful规范，现在就很容易理解我们为什么用CBV了。","categories":[{"name":"django-rest-framework","slug":"django-rest-framework","permalink":"https://liangweijiang.github.io/categories/django-rest-framework/"}],"tags":[{"name":"DRF","slug":"DRF","permalink":"https://liangweijiang.github.io/tags/DRF/"}]}]}