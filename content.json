{"meta":{"title":"Hexo","subtitle":"","description":"","author":"liangweijiang","url":"https://liangweijiang.github.io","root":"/"},"pages":[{"title":"categories","date":"2020-02-19T09:53:30.000Z","updated":"2020-02-19T09:54:44.015Z","comments":true,"path":"categories/index.html","permalink":"https://liangweijiang.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-02-19T10:00:45.000Z","updated":"2020-02-19T10:01:19.886Z","comments":true,"path":"tags/index.html","permalink":"https://liangweijiang.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"每日一道算法之--三数之和","slug":"algorithm-15","date":"2020-02-24T09:25:51.544Z","updated":"2020-02-24T10:04:12.396Z","comments":true,"path":"2020/02/24/algorithm-15/","link":"","permalink":"https://liangweijiang.github.io/2020/02/24/algorithm-15/","excerpt":"","text":"三数之和力扣第15题：https://leetcode-cn.com/problems/3sum/给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。 注意：答案中不可以包含重复的三元组。 示例： 给定数组 nums = [-1, 0, 1, 2, -1, -4]，满足要求的三元组集合为：[ [-1, 0, 1], [-1, -1, 2]] 1. 排序 + 双指针解法题目中的要求是不能含有相同的三元组，所以在算法中我们需要去重，排序是一个很好的方法，因为排序可以让相同的数连载一起，方便判断去重。让后在通过双指针对数组一一检查，找到所有合适的三元组。 1234567891011121314151617181920212223242526272829class Solution: def threeSum(self, nums: List[int]) -&gt; List[List[int]]: # 先将nums排序 nums.sort() res = [] for i in range(len(nums) - 2): # 设置两个指针 l, r = i + 1, len(nums) - 1 if nums[i] &gt; 0 : return res # 去除重复的判断,因为nums[i -1]已经包含了nums[i]的所有组合的可能性 if i &gt; 0 and nums[i] == nums[i - 1] : continue while l &lt; r: s = nums[i] + nums[l] + nums[r] if s &lt; 0: # 如果和小于0，证明左边的数太小了，需要往后移 l += 1 # 去除重复的判断，但是前提条件为l&lt;r while l &lt; r and nums[l] == nums[l - 1]: l += 1 elif s &gt; 0: r -= 1 # 如果和大于0，证明右边的数太大了，需要往前移 while l &lt; r and nums[r] == nums[r + 1]: r -= 1 else: res.append([nums[i], nums[l], nums[r]]) l += 1 r -= 1 while l &lt; r and nums[l] == nums[l - 1]: l += 1 while l &lt; r and nums[r] == nums[r + 1]: r -= 1 return res 1.1 时间复杂度分析 时间复杂度：排序的时间复杂度为 O(NlogN), 遍历数组为O(N),双指针的遍历为O(N),所以总的时间复杂度为$$O(NlogN)+0(N)*O(N) = O(N^2)$$ 空间复杂度：没有用到额外的数据结构，所以空间复杂度为$$O(1)$$ 2.哈希索引的方法（空间换时间）参考两数之和，我们可以构建哈希表的方法使查找效率变得更高。 12345678910111213141516171819202122232425262728class Solution: def threeSum(self, nums: List[int]) -&gt; List[List[int]]: if len(nums) &lt; 3: return [] nums.sort() # 因为a+b = 0等价于a = -b target_hash = &#123;-x: i for i, x in enumerate(nums)&#125; res = [] res_hash = &#123;&#125; # 从零开始检索,到倒数第二位结束 for i, first in enumerate(nums[:-1]): if nums[i] &gt; 0: return res if i &gt; 0 and first == nums[i - 1]: continue #从第一个指针的下一位开始搜索 for j, second in enumerate(nums[i + 1:]): # 检查两数之和是否存在于哈希表target_hash中 if first + second in target_hash: target_index = target_hash[first + second] if target_index == i or target_index == i + j + 1: continue # 将找到的结果存入另一个哈希表中, 避免包含重复结果 row = sorted([first, second, nums[target_index]]) key = \",\".join([str(x) for x in row]) if key not in res_hash: res.append(row) res_hash[key] = True return res","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://liangweijiang.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"双指针,哈希","slug":"双指针-哈希","permalink":"https://liangweijiang.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88-%E5%93%88%E5%B8%8C/"}]},{"title":"DRF源码解析4--版本控制组件的封装","slug":"DRF-04","date":"2020-02-22T14:09:24.712Z","updated":"2020-02-22T14:11:09.294Z","comments":true,"path":"2020/02/22/DRF-04/","link":"","permalink":"https://liangweijiang.github.io/2020/02/22/DRF-04/","excerpt":"","text":"一.DRF中APIView的initial()方法初始化版本信息在讲到DRF对ruquest的封装时,返回新封装的Request后,DRF执行了initial()方法对组件的初始化 12345678910111213def initial(self, request, *args, **kwargs): # 版本控制组件 version, scheme = self.determine_version(request, *args, **kwargs) # 将版本空值信息写入request中 request.version, request.versioning_scheme = version, scheme # Ensure that the incoming request is permitted # 认证组件 self.perform_authentication(request) # 权限组件 self.check_permissions(request) # 频率 self.check_throttles(request) 1.1重写determine_version()自定制版本信息12345678910 def determine_version(self, request, *args, **kwargs): \"\"\" If versioning is being used, then determine any API version for the incoming request. Returns a two-tuple of (version, versioning_scheme) \"\"\" if self.versioning_class is None: return (None, None)# self.versioning_class是drf配置默认的类,说明我们自定义版本时要重写这个方法 scheme = self.versioning_class() return (scheme.determine_version(request, *args, **kwargs), scheme) 二.rest_framework.versioning提供的版本控制方法 2.1 BaseVersioning1234567891011121314151617181920212223class BaseVersioning: # default_version(None), allowed_versions(None), version_param可以在settings中重新配置 default_version = api_settings.DEFAULT_VERSION allowed_versions = api_settings.ALLOWED_VERSIONS version_param = api_settings.VERSION_PARAM def determine_version(self, request, *args, **kwargs): # 在继承该类时要重写determine_version(方法) msg = '&#123;cls&#125;.determine_version() must be implemented.' raise NotImplementedError(msg.format( cls=self.__class__.__name__ )) def reverse(self, viewname, args=None, kwargs=None, request=None, format=None, **extra): # 和django.urls.reverse大致相同, # 但可以选择接受一个请求并返回使用请求获取基本URL的标准URL。 return _reverse(viewname, args, kwargs, request, format, **extra) def is_allowed_version(self, version): if not self.allowed_versions: return True return ((version is not None and version == self.default_version) or (version in self.allowed_versions)) 2.2 URLPathVersioning1234567891011121314151617181920212223242526272829303132333435363738class URLPathVersioning(BaseVersioning): \"\"\" To the client this is the same style as `NamespaceVersioning`. The difference is in the backend - this implementation uses Django's URL keyword arguments to determine the version. An example URL conf for two views that accept two different versions. 可以看到版本信息就在url中 urlpatterns = [ url(r'^(?P&lt;version&gt;[v1|v2]+)/users/$', users_list, name='users-list'), url(r'^(?P&lt;version&gt;[v1|v2]+)/users/(?P&lt;pk&gt;[0-9]+)/$', users_detail, name='users-detail') ] GET /1.0/something/ HTTP/1.1 Host: example.com Accept: application/json \"\"\" invalid_version_message = _('Invalid version in URL path.') def determine_version(self, request, *args, **kwargs): # self.version_param,self.default_version是父类中的属性,可以自定义 version = kwargs.get(self.version_param, self.default_version) if version is None: # 如果没有自己配置默认为DRF默认的版本信息 version = self.default_version if not self.is_allowed_version(version): raise exceptions.NotFound(self.invalid_version_message) return version def reverse(self, viewname, args=None, kwargs=None, request=None, format=None, **extra): if request.version is not None: kwargs = &#123;&#125; if (kwargs is None) else kwargs # self.version_param就是版本的key kwargs[self.version_param] = request.version return super().reverse( viewname, args, kwargs, request, format, **extra 其他的类基本配置都差不多","categories":[{"name":"django-rest-framework","slug":"django-rest-framework","permalink":"https://liangweijiang.github.io/categories/django-rest-framework/"}],"tags":[{"name":"DRF","slug":"DRF","permalink":"https://liangweijiang.github.io/tags/DRF/"}]},{"title":"DRF源码解析3--routers对路由的封装","slug":"DRF-03","date":"2020-02-20T15:15:11.102Z","updated":"2020-02-20T15:16:50.088Z","comments":true,"path":"2020/02/20/DRF-03/","link":"","permalink":"https://liangweijiang.github.io/2020/02/20/DRF-03/","excerpt":"","text":"当我们想最方便的使用drf的路由的时候,只需要用DefaultRoute实例化一个路由实例,然后注册,再讲注册后的组件加入urlpatterns即可 123456from rest_framework.routers import DefaultRouterrouter = DefaultRouter()# 其中BookModelView继承了viewsets.ModelViewSetrouter.register(r'^book', views.BookModelView)urlpatterns += router.urls 到底routers底层是怎么样实现的呢 routersDefaultRoute是routers组件里的一个类,相当于帮助我们在路由里构建好了如{‘list’:”create”}的对应关系,它继承了SimpleRouter,截取源码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102class SimpleRouter(BaseRouter): routes = [ # List route. Route( url=r'^&#123;prefix&#125;&#123;trailing_slash&#125;$', # 这里构建好了对应关系 mapping=&#123; 'get': 'list', 'post': 'create' &#125;, name='&#123;basename&#125;-list', detail=False, initkwargs=&#123;'suffix': 'List'&#125; ), def __init__(self, trailing_slash=True): self.trailing_slash = '/' if trailing_slash else '' super().__init__() def get_default_basename(self, viewset): \"\"\" If `basename` is not specified, attempt to automatically determine it from the viewset. \"\"\" queryset = getattr(viewset, 'queryset', None) assert queryset is not None, '`basename` argument not specified, and could ' \\ 'not automatically determine the name from the viewset, as ' \\ 'it does not have a `.queryset` attribute.' return queryset.model._meta.object_name.lower() def get_routes(self, viewset): # 获取对应关系 known_actions = list(flatten([route.mapping.values() for route in self.routes if isinstance(route, Route)])) # 找出viewsets里所有的方法 extra_actions = viewset.get_extra_actions() # checking action names against the known actions list # 判断路由的方法对应的viewsets的方法 not_allowed = [ action.__name__ for action in extra_actions if action.__name__ in known_actions ] if not_allowed: msg = ('Cannot use the @action decorator on the following ' 'methods, as they are existing routes: %s') raise ImproperlyConfigured(msg % ', '.join(not_allowed)) # partition detail and list actions detail_actions = [action for action in extra_actions if action.detail] list_actions = [action for action in extra_actions if not action.detail] routes = [] for route in self.routes: if isinstance(route, DynamicRoute) and route.detail: routes += [self._get_dynamic_route(route, action) for action in detail_actions] elif isinstance(route, DynamicRoute) and not route.detail: routes += [self._get_dynamic_route(route, action) for action in list_actions] else: routes.append(route) return routes def get_urls(self): \"\"\" Use the registered viewsets to generate a list of URL patterns. \"\"\" ret = [] # 这里的self.registry是父类BaseRouter的一个属性 for prefix, viewset, basename in self.registry: lookup = self.get_lookup_regex(viewset) routes = self.get_routes(viewset) # 这里是对路径进行了不同形式的封装 for route in routes: # Only actions which actually exist on the viewset will be bound mapping = self.get_method_map(viewset, route.mapping) if not mapping: continue # Build the url pattern regex = route.url.format( prefix=prefix, lookup=lookup, trailing_slash=self.trailing_slash ) if not prefix and regex[:2] == '^/': regex = '^' + regex[2:] initkwargs = route.initkwargs.copy() initkwargs.update(&#123; 'basename': basename, 'detail': route.detail, &#125;) view = viewset.as_view(mapping, **initkwargs) name = route.name.format(basename=basename) ret.append(url(regex, view, name=name)) return ret 进入BaseRouter中,截取源码如下: 1234567891011121314151617181920212223242526272829303132333435class BaseRouter: def __init__(self): # SimpleRouter的get_urls中的需要的属性 self.registry = [] def register(self, prefix, viewset, basename=None): # 如果没有basename,则self.get_default_basename()方法 # get_default_basename()方法就是报错要求basename必须有, # 从而看得出来要想使用router组件必须执行register()方法 if basename is None: basename = self.get_default_basename(viewset) self.registry.append((prefix, viewset, basename)) # invalidate the urls cache if hasattr(self, '_urls'): del self._urls def get_default_basename(self, viewset): \"\"\" If `basename` is not specified, attempt to automatically determine it from the viewset. \"\"\" raise NotImplementedError('get_default_basename must be overridden') def get_urls(self): \"\"\" Return a list of URL patterns, given the registered viewsets. \"\"\" raise NotImplementedError('get_urls must be overridden') @property def urls(self): if not hasattr(self, '_urls'): self._urls = self.get_urls() return self._urls DefaultRoute类进行了更好的优化 123456789101112131415161718192021222324252627282930313233343536373839404142class DefaultRouter(SimpleRouter): \"\"\" The default router extends the SimpleRouter, but also adds in a default API root view, and adds format suffix patterns to the URLs. \"\"\" include_root_view = True include_format_suffixes = True root_view_name = 'api-root' default_schema_renderers = None APIRootView = APIRootView APISchemaView = SchemaView SchemaGenerator = SchemaGenerator def __init__(self, *args, **kwargs): if 'root_renderers' in kwargs: self.root_renderers = kwargs.pop('root_renderers') else: self.root_renderers = list(api_settings.DEFAULT_RENDERER_CLASSES) super().__init__(*args, **kwargs) def get_api_root_view(self, api_urls=None): \"\"\" Return a basic root view. \"\"\" api_root_dict = OrderedDict() list_name = self.routes[0].name for prefix, viewset, basename in self.registry: api_root_dict[prefix] = list_name.format(basename=basename) return self.APIRootView.as_view(api_root_dict=api_root_dict) def get_urls(self): urls = super().get_urls() if self.include_root_view: view = self.get_api_root_view(api_urls=urls) root_url = url(r'^$', view, name=self.root_view_name) urls.append(root_url) if self.include_format_suffixes: urls = format_suffix_patterns(urls) return urls 最后路由组件创建了怎么样的url?","categories":[{"name":"django-rest-framework","slug":"django-rest-framework","permalink":"https://liangweijiang.github.io/categories/django-rest-framework/"}],"tags":[{"name":"DRF","slug":"DRF","permalink":"https://liangweijiang.github.io/tags/DRF/"}]},{"title":"DRF源码解析2--viewsets.ModelViewSet对视图的封装","slug":"DRF-02","date":"2020-02-19T13:47:47.427Z","updated":"2020-02-19T15:08:42.664Z","comments":true,"path":"2020/02/19/DRF-02/","link":"","permalink":"https://liangweijiang.github.io/2020/02/19/DRF-02/","excerpt":"","text":"viewsetsdrf中 viewsets 对 view 进行了更加深层的封装,在CBV编程中减少代码的冗余,截取viewsets源码如下 12345678class ModelViewSet(mixins.CreateModelMixin, mixins.RetrieveModelMixin, mixins.UpdateModelMixin, mixins.DestroyModelMixin, mixins.ListModelMixin, GenericViewSet):# 可以看到viewsets中的ModelViewSet只是继承了各种类,每一个类对应CBV的每一个方法,如CreateModelMixin则对应post方法 pass 进入GenericViewSet的源码中,不难发现,GenericViewSet这个类主要是获取我们的数据和处理数据的组件 123class GenericViewSet(ViewSetMixin, generics.GenericAPIView): # GenericViewSet同样是继承了两个类 pass 进入generics.GenericAPIView 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657class GenericAPIView(views.APIView): # queryset就是获取的ORM对象 queryset = None # serializer_class是序列化的类 serializer_class = None lookup_field = 'pk' lookup_url_kwarg = None # The filter backend classes to use for queryset filtering filter_backends = api_settings.DEFAULT_FILTER_BACKENDS # The style to use for queryset pagination. # pagination_class就是和分页组件相关的类,默认为drf配置中的组件 pagination_class = api_settings.DEFAULT_PAGINATION_CLASS def get_queryset(self): # 这里断言就是为了说明在继承这个类时,一定要有queryset属性或覆盖这个方法 assert self.queryset is not None, ( \"'%s' should either include a `queryset` attribute, \" \"or override the `get_queryset()` method.\" % self.__class__.__name__ ) # 获取ORM对象 queryset = self.queryset if isinstance(queryset, QuerySet): # Ensure queryset is re-evaluated on each request. queryset = queryset.all() return queryset def get_serializer(self, *args, **kwargs): serializer_class = self.get_serializer_class() kwargs['context'] = self.get_serializer_context() # serializer_class接收的参数可能不同 return serializer_class(*args, **kwargs) def get_serializer_class(self): # 继承这个类时,一定要有serializer_classt属性或覆盖这个方法 assert self.serializer_class is not None, ( \"'%s' should either include a `serializer_class` attribute, \" \"or override the `get_serializer_class()` method.\" % self.__class__.__name__ ) return self.serializer_class def get_serializer_context(self): return &#123; 'request': self.request, 'format': self.format_kwarg, 'view': self &#125; def filter_queryset(self, queryset): for backend in list(self.filter_backends): queryset = backend().filter_queryset(self.request, queryset, self) return queryset 接着回到ModelViewSet中,进入到mixins.CreateModelMixin的源码中 1234567891011121314151617181920class CreateModelMixin: \"\"\" Create a model instance. \"\"\" def create(self, request, *args, **kwargs): # 这里调用的就是GenericAPIView中的get_serializer serializer = self.get_serializer(data=request.data) serializer.is_valid(raise_exception=True) self.perform_create(serializer) headers = self.get_success_headers(serializer.data) return Response(serializer.data, status=status.HTTP_201_CREATED, headers=headers) def perform_create(self, serializer): serializer.save() def get_success_headers(self, data): try: return &#123;'Location': str(data[api_settings.URL_FIELD_NAME])&#125; except (TypeError, KeyError): return &#123;&#125; 现在我们只需要继承ModelViewSet,然后重写queryset和处理数据所需要的组件类如序列化的类等,但是怎么将self.post对应上self.list方法呢,GenericViewSet还继承了ViewSetMixin,看一下ViewSetMixin的源码的截取 1234567891011121314151617181920212223242526272829303132333435class ViewSetMixin: @classonlymethod # 对as_view()方法又一次封装,action表示可以接收参数了 def as_view(cls, actions=None, **initkwargs): if not actions: raise TypeError(\"The `actions` argument must be provided when \" \"calling `.as_view()` on a ViewSet. For example \" \"`.as_view(&#123;'get': 'list'&#125;)`\") def view(request, *args, **kwargs): self = cls(**initkwargs) # We also store the mapping of request methods to actions, # so that we can later set the action attribute. # eg. `self.action = 'list'` on an incoming GET request. self.action_map = actions # Bind methods to actions # This is the bit that's different to a standard view # method, action退出action为一个字典,&#123;'get':'list'&#125; for method, action in actions.items(): # handler为实例中的各个方法 handler = getattr(self, action) # 这里setattr相当于metmod == handler setattr(self, method, handler) if hasattr(self, 'get') and not hasattr(self, 'head'): self.head = self.get self.request = request self.args = args self.kwargs = kwargs # And continue as usual return self.dispatch(request, *args, **kwargs) return csrf_exempt(view) 奉献一张图来看下我们的继承顺序","categories":[{"name":"django-rest-framework","slug":"django-rest-framework","permalink":"https://liangweijiang.github.io/categories/django-rest-framework/"}],"tags":[{"name":"DRF","slug":"DRF","permalink":"https://liangweijiang.github.io/tags/DRF/"}]},{"title":"DRF源码解析1--APIView对request的重新封装","slug":"DRF-01","date":"2020-02-19T08:58:37.586Z","updated":"2020-02-19T10:08:43.094Z","comments":true,"path":"2020/02/19/DRF-01/","link":"","permalink":"https://liangweijiang.github.io/2020/02/19/DRF-01/","excerpt":"","text":"截取APIView12345678910111213141516171819202122232425262728293031323334353637383940414243444546@classmethodclass APIView(View): def as_view(cls, **initkwargs): if isinstance(getattr(cls, 'queryset', None), models.query.QuerySet): def force_evaluation(): raise RuntimeError( 'Do not evaluate the `.queryset` attribute directly, ' 'as the result will be cached and reused between requests. ' 'Use `.all()` or call `.get_queryset()` instead.' ) cls.queryset._fetch_all = force_evaluation # 继承了django中View类的的as_view()方法,然后重写了dispatch方法 view = super().as_view(**initkwargs) view.cls = cls view.initkwargs = initkwargs return csrf_exempt(view) def dispatch(self, request, *args, **kwargs): self.args = args self.kwargs = kwargs # 在传入request是,apiview对request进行了一次包装 request = self.initialize_request(request, *args, **kwargs) # 此时self.request是initialize_request方法返回的Request self.request = request self.headers = self.default_response_headers # deprecate? try: # 相比于View类的dispatch方法,Apiview在这里进行了一次初始化的方法 self.initial(request, *args, **kwargs) # Get the appropriate handler method if request.method.lower() in self.http_method_names: handler = getattr(self, request.method.lower(), self.http_method_not_allowed) else: handler = self.http_method_not_allowed response = handler(request, *args, **kwargs) except Exception as exc: response = self.handle_exception(exc) self.response = self.finalize_response(request, response, *args, **kwargs) return self.response 进入self.initalize_request()12345678910def initialize_request(self, request, *args, **kwargs): parser_context = self.get_parser_context(request) # 可以看到, request已经被封装成Request返回,而request则被封装成Request的一个属性 return Request( request, parsers=self.get_parsers(), authenticators=self.get_authenticators(), negotiator=self.get_content_negotiator(), parser_context=parser_context ) 截取Ruquest123456789101112131415161718192021222324252627282930class Request: def __init__(self, request, parsers=None, authenticators=None, negotiator=None, parser_context=None): assert isinstance(request, HttpRequest), ( 'The `request` argument must be an instance of ' '`django.http.HttpRequest`, not `&#123;&#125;.&#123;&#125;`.' .format(request.__class__.__module__, request.__class__.__name__) ) # request被封装了私有属性 self._request = request @property def content_type(self): meta = self._request.META # 封装了content_type方法获取传输类型 return meta.get('CONTENT_TYPE', meta.get('HTTP_CONTENT_TYPE', '')) @property def query_params(self): \"\"\" More semantically correct name for request.GET. \"\"\" # django的view中的request.Get属性封装成了query_params属性 return self._request.GET @property def data(self): if not _hasattr(self, '_full_data'): self._load_data_and_files() # django的view中的request.Post属性封装成了data属性 return self._full_data 我们可以看出~CBV在内部做了一个分发,本质和FBV是一样的。 以后做接口开发的时候，就要用CBV，学习了restful规范，现在就很容易理解我们为什么用CBV了。","categories":[{"name":"django-rest-framework","slug":"django-rest-framework","permalink":"https://liangweijiang.github.io/categories/django-rest-framework/"}],"tags":[{"name":"DRF","slug":"DRF","permalink":"https://liangweijiang.github.io/tags/DRF/"}]}]}