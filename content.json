{"meta":{"title":"Hexo","subtitle":"","description":"","author":"liangweijiang","url":"https://liangweijiang.github.io","root":"/"},"pages":[{"title":"categories","date":"2020-02-19T09:53:30.000Z","updated":"2020-02-19T09:54:44.015Z","comments":true,"path":"categories/index.html","permalink":"https://liangweijiang.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-02-19T10:00:45.000Z","updated":"2020-02-19T10:01:19.886Z","comments":true,"path":"tags/index.html","permalink":"https://liangweijiang.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"python的垃圾回收机制","slug":"python-GC","date":"2020-03-04T04:07:35.310Z","updated":"2020-03-04T04:19:00.241Z","comments":true,"path":"2020/03/04/python-GC/","link":"","permalink":"https://liangweijiang.github.io/2020/03/04/python-GC/","excerpt":"","text":"python的垃圾回收机制 垃圾回收机制是自动帮助我们管理内存，清理垃圾的一种工具1）、引用计数当一个对象的引用被创建或者复制时，对象的引用计数加1；当一个对象的引用被销毁时，对象的引用计数减1；当对象的引用计数减少为0时，就意味着对象已经没有被任何人使用了，可以将其所占用的内存释放了。2）、标记-清除标记-清除不改动真实的引用计数，而是将集合中对象的引用计数复制一份副本，改动该对象引用的副本。对于副本做任何的改动，都不会影响到对象生命走起的维护。3）、分代回收将系统中的所有内存块根据其存活时间划分为不同的集合，每一个集合就成为一个“代”，垃圾收集的频率随着“代”的存活时间的增大而减小。也就是说，活得越长的对象，就越不可能是垃圾，就应该减少对它的垃圾收集频率。那么如何来衡量这个存活时间：通常是利用几次垃圾收集动作来衡量，如果一个对象经过的垃圾收集次数越多，可以得出：该对象存活时间就越长。 1. 引用计数python一切皆对象,每一个对象都保存了一个称为引用计数的整数值，来追踪到底有多少引用指向了这个对象。无论何时，如果我们程序中的一个变量或其他对象引用了目标对象，Python将会增加这个计数值。 对象被创建 a=14 对象被引用 b=a 对象被作为参数,传到函数中 func(a) 对象作为一个元素，存储在容器中 List={a,”a”,”b”,2} 而当程序停止使用这个对象，则Python会减少这个计数值。一旦计数值被减到零，Python将会释放这个对象以及回收相关内存空间。 当该对象的别名被显式销毁时 del a 当该对象的引别名被赋予新的对象， a=26 一个对象离开它的作用域，例如 func函数执行完毕时，函数里面的局部变量的引用计数器就会减一（但是全局变量不会） 将该元素从容器中删除时，或者容器被销毁时。 当指向该对象的内存的引用计数器为0的时候，该内存将会被Python虚拟机销毁 1.1 引用计数的优点可以看出,引用计数有以下几个优点: 高效 运行期没有停顿 可以类比一下Ruby的垃圾回收机制，也就是 实时性：一旦没有引用，内存就直接释放了。不用像其他机制等到特定时机。实时性还带来一个好处：处理回收内存的时间分摊到了平时。 对象有确定的生命周期 易于实现,简单直观 但是针对引用计数这种算法来说，如果一个数据结构引用了它自身，即如果这个数据结构是一个循环数据结构，那么某些引用计数值是肯定无法变成零的。为了更好地理解这个问题，让我们举个例子。 123456a = &#123; &#125; #对象A的引用计数为 1b = &#123; &#125; #对象B的引用计数为 1a['b'] = b #B的引用计数增1b['a'] = a #A的引用计数增1del a #A的引用减 1，最后A对象的引用为 1del b #B的引用减 1, 最后B对象的引用为 1 在这个例子中程序执行完del语句后，A、B对象已经没有任何引用指向这两个对象，但是这两个对象各包含一个对方对象的引用，虽然最后两个对象都无法通过其它变量来引用这两个对象了，这对GC来说就是两个非活动对象或者说是垃圾对象，但是他们的引用计数并没有减少到零。因此如果是使用引用计数法来管理这两对象的话，他们并不会被回收，它会一直驻留在内存中，就会造成了内存泄漏（内存空间在使用完毕后未释放）。 1.2 引用计数的缺点虽然引用计数有着非常简单高效的优点,但是他也有这致命的缺点 维护引用计数消耗资源，维护引用计数的次数和引用赋值成正比，而不像mark and sweep等基本与回收的内存数量有关。 无法解决循环引用的问题 为了解决对象的循环引用问题，Python引入了标记-清除和分代回收两种GC机制。 2. 标记清除 『标记清除（Mark—Sweep）』算法是一种基于追踪回收（tracing GC）技术实现的垃圾回收算法。它分为两个阶段：第一阶段是标记阶段，GC会把所有的『活动对象』打上标记，第二阶段是把那些没有标记的对象『非活动对象』进行回收。那么GC又是如何判断哪些是活动对象哪些是非活动对象的呢？ 对象之间通过引用（指针）连在一起，构成一个有向图，对象构成这个有向图的节点，而引用关系构成这个有向图的边。从根对象（root object）出发，沿着有向边遍历对象，可达的（reachable）对象标记为活动对象，不可达的对象就是要被清除的非活动对象。根对象就是全局变量、调用栈、寄存器。 A）标记阶段，遍历所有的对象，如果是可达的（reachable），也就是还有对象引用它，那么就标记该对象为可达； B）清除阶段，再次遍历对象，如果发现某个对象没有标记为可达，则就将其回收。 在上图中，我们把小黑圈视为全局变量，也就是把它作为root object，从小黑圈出发，对象1可直达，那么它将被标记，对象2、3可间接到达也会被标记，而4和5不可达，那么1、2、3就是活动对象，4和5是非活动对象会被GC回收。 标记清除算法作为Python的辅助垃圾收集技术主要处理的是一些容器对象，比如list、dict、tuple，instance等，因为对于字符串、数值对象是不可能造成循环引用问题。Python使用一个双向链表将这些容器对象组织起来。 不过，这种简单粗暴的标记清除算法也有明显的缺点：清除非活动的对象前它必须顺序扫描整个堆内存，哪怕只剩下小部分活动对象也要扫描所有对象，而且会暂停整个应用程序，等待标记清除结束后才会恢复应用程序的运行 3. 分代回收分代回收是一种以空间换时间的操作方式，Python将内存根据对象的存活时间划分为不同的集合，每个集合称为一个代，Python将内存分为了3“代”，分别为年轻代（第0代）、中年代（第1代）、老年代（第2代），他们对应的是3个链表，它们的垃圾收集频率与对象的存活时间的增大而减小。新创建的对象都会分配在年轻代，年轻代链表的总数达到上限时，Python垃圾收集机制就会被触发，把那些可以被回收的对象回收掉，而那些不会回收的对象就会被移到中年代去，依此类推，老年代中的对象是存活时间最久的对象，甚至是存活于整个系统的生命周期内。同时，分代回收是建立在标记清除技术基础之上。分代回收同样作为Python的辅助垃圾收集技术处理那些容器对象。 分代回收是基于这样的一个统计事实，对于程序，存在一定比例的内存块的生存周期比较短；而剩下的内存块，生存周期会比较长，甚至会从程序开始一直持续到程序结束。生存期较短对象的比例通常在 80%～90% 之间，这种思想简单点说就是：对象存在时间越长，越可能不是垃圾，应该越少去收集。这样在执行标记-清除算法时可以有效减小遍历的对象数，从而提高垃圾回收的速度。 Python默认定义了三代对象集合，索引数越大，对象存活时间越长12345678910#define NUM_GENERATIONS 3#define GEN_HEAD(n) (&amp;generations[n].head)/* linked lists of container objects */static struct gc_generation generations[NUM_GENERATIONS] = &#123; /* PyGC_Head, threshold, count */ &#123;&#123;&#123;GEN_HEAD(0), GEN_HEAD(0), 0&#125;&#125;, 700, 0&#125;, &#123;&#123;&#123;GEN_HEAD(1), GEN_HEAD(1), 0&#125;&#125;, 10, 0&#125;, &#123;&#123;&#123;GEN_HEAD(2), GEN_HEAD(2), 0&#125;&#125;, 10, 0&#125;,&#125;; 新生成的对象会被加入第0代，前面_PyObject_GC_Malloc中省略的部分就是Python GC触发的时机。每新生成一个对象都会检查第0代有没有满，如果满了就开始着手进行垃圾回收.1234567891011g-&gt;gc.gc_refs = GC_UNTRACKED; generations[0].count++; /* number of allocated GC objects */ if (generations[0].count &gt; generations[0].threshold &amp;&amp; enabled &amp;&amp; generations[0].threshold &amp;&amp; !collecting &amp;&amp; !PyErr_Occurred()) &#123; collecting = 1; collect_generations(); collecting = 0; &#125; 3.1 在Python中的零代(Generation Zero)很多时候你的代码也许会在不经意间包含循环引用并且你并未意识到。事实上，当你的Python程序运行的时候它将会建立一定数量的“浮点数垃圾”，Python的GC不能够处理未使用的对象因为应用计数值不会到零。就是为什么Python要引入Generational GC算法的原因！正如Ruby使用一个链表(free list)来持续追踪未使用的、自由的对象一样，Python使用一种不同的链表来持续追踪活跃的对象。而不将其称之为“活跃列表”，Python的内部C代码将其称为零代(Generation Zero)。每次当你创建一个对象或其他什么值的时候，Python会将其加入零代链表。请注意到这并不是一个真正的列表，并不能直接在你的代码中访问，事实上这个链表是一个完全内部的Python运行体 3.2 Python中的GC阈值随着你的程序运行，Python解释器保持对新创建的对象，以及因为引用计数为零而被释放掉的对象的追踪。从理论上说，这两个值应该保持一致，因为程序新建的每个对象都应该最终被释放掉。 当然，事实并非如此。因为循环引用的原因，并且因为你的程序使用了一些比其他对象存在时间更长的对象，从而被分配对象的计数值与被释放对象的计数值之间的差异在逐渐增长。一旦这个差异累计超过某个阈值，则Python的收集机制就启动了，并且触发上边所说到的零代算法，释放“浮动的垃圾”，并且将剩下的对象移动到一代列表。 随着时间的推移，程序所使用的对象逐渐从零代列表移动到一代列表。而Python对于一代列表中对象的处理遵循同样的方法，一旦被分配计数值与被释放计数值累计到达一定阈值，Python会将剩下的活跃对象移动到二代列表。 通过这种方法，你的代码所长期使用的对象，那些你的代码持续访问的活跃对象，会从零代链表转移到一代再转移到二代。通过不同的阈值设置，Python可以在不同的时间间隔处理这些对象。Python处理零代最为频繁，其次是一代然后才是二代。 3.3 弱代假说来看看代垃圾回收算法的核心行为：垃圾回收器会更频繁的处理新对象。一个新的对象即是你的程序刚刚创建的，而一个来的对象则是经过了几个时间周期之后仍然存在的对象。Python会在当一个对象从零代移动到一代，或是从一代移动到二代的过程中提升(promote)这个对象。 为什么要这么做？这种算法的根源来自于弱代假说(weak generational hypothesis)。这个假说由两个观点构成：首先是年亲的对象通常死得也快，而老对象则很有可能存活更长的时间。 假定现在我用Python或是Ruby创建一个新对象 n1=”ABC”： 根据假说，我的代码很可能仅仅会使用ABC很短的时间。这个对象也许仅仅只是一个方法中的中间结果，并且随着方法的返回这个对象就将变成垃圾了。大部分的新对象都是如此般地很快变成垃圾。然而，偶尔程序会创建一些很重要的，存活时间比较长的对象-例如web应用中的session变量或是配置项。 通过频繁的处理零代链表中的新对象，Python的垃圾收集器将把时间花在更有意义的地方：它处理那些很快就可能变成垃圾的新对象。同时只在很少的时候，当满足阈值的条件，收集器才回去处理那些老变量。 分代回收的逻辑分配内存-&gt; 发现超过阈值了-&gt; 触发垃圾回收-&gt; 将所有可收集对象链表放到一起-&gt; 遍历, 计算有效引用计数-&gt; 分成 有效引用计数=0 和 有效引用计数 &gt; 0 两个集合-&gt; 大于0的, 放入到更老一代-&gt; =0的, 执行回收-&gt; 回收遍历容器内的各个元素, 减掉对应元素引用计数(破掉循环引用)-&gt; 执行-1的逻辑, 若发现对象引用计数=0, 触发内存回收-&gt; python底层内存管理机制回收内存 总结总体来说，在Python中，主要通过引用计数进行垃圾回收；通过 “标记-清除” 解决容器对象可能产生的循环引用问题；通过 “分代回收” 以空间换时间的方法提高垃圾回收效率。 参考文章：一文搞定Python垃圾回收机制Python垃圾回收机制–完美讲解!Python中的垃圾回收机制PYTHON 源码阅读 - 垃圾回收机制《垃圾回收的算法与实现》","categories":[{"name":"python","slug":"python","permalink":"https://liangweijiang.github.io/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://liangweijiang.github.io/tags/python/"}]},{"title":"每日一道算法之--有效的括号","slug":"algorithm-20","date":"2020-03-03T11:41:23.245Z","updated":"2020-03-03T11:42:43.389Z","comments":true,"path":"2020/03/03/algorithm-20/","link":"","permalink":"https://liangweijiang.github.io/2020/03/03/algorithm-20/","excerpt":"","text":"有效的括号力扣第20题 : https://leetcode-cn.com/problems/valid-parentheses/ 给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。 有效字符串需满足： 左括号必须用相同类型的右括号闭合。左括号必须以正确的顺序闭合。注意空字符串可被认为是有效字符串。 示例 1: 输入: “()”输出: true 示例 2: 输入: “()[]{}”输出: true 示例 3: 输入: “(]”输出: false 题目分析题目不难理解,就是括号要一一对应,换句话来说,只要出现了右括号,name就必定有一个左括号与之对应,而且左括号和右括号必须是对称的,刚好栈这种数据结构可以很好地实现这一目的. 要想一一对应,字符串长度必须是偶数 遍历这个数组,每当遇到左括号时,直接入栈 当遇到有括号时,就取出栈顶元素,然后与该括号配对,若配对失败,则证明字符串无效,若配对成功,则继续遍历 直到数组遍历完成并且栈里没有元素以后,则证明字符串有效 翻译成代码如下: 123456789101112class Solution: def isValid(self, s: str) -&gt; bool: has_map = &#123;')':'(', '&#125;':'&#123;', ']':'['&#125; stack = [] if len(s) % 2 != 0: return False for char in s: if char in has_map: top_ele = stack.pop() if stack else '' if top_ele != has_map[char]: return False else: stack.append(char) return not stack 复杂度分析时间复杂度：因为我们一次只遍历给定的字符串中的一个字符并在栈上进行 O(1) 的推入和弹出操作,所以时间复杂度为O(n)。 空间复杂度：在最糟糕的情况下，我们最终要把所有括号推到栈上。例如 ((((((((((, 而如果是有效字符串,则也要将n/2的括号入栈,所以空间复杂度为O(n)。","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://liangweijiang.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"栈","slug":"栈","permalink":"https://liangweijiang.github.io/tags/%E6%A0%88/"},{"name":"数组","slug":"数组","permalink":"https://liangweijiang.github.io/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"每日一道算法之--二叉树的层次遍历","slug":"algorithm-102","date":"2020-03-03T09:46:49.296Z","updated":"2020-03-03T10:35:03.161Z","comments":true,"path":"2020/03/03/algorithm-102/","link":"","permalink":"https://liangweijiang.github.io/2020/03/03/algorithm-102/","excerpt":"","text":"二叉树的层次遍历力扣第102题 : https://leetcode-cn.com/problems/binary-tree-level-order-traversal/ 给定一个二叉树，返回其按层次遍历的节点值。 （即逐层地，从左到右访问所有节点）。 例如: 给定二叉树: [3,9,20,null,null,15,7], 3 / 9 20 / 15 7 返回其层次遍历结果： [ [3], [9,20], [15,7]] 1.递归一开始看到这题时,因为之前学过二叉树的知识,所以我知道这道题的第一思路就是递归但是这道层次遍历的主要问题就是,数是分左右节点的,如果直接递归,那么同一层的左右节点就不会给同时读取.所以,能不能先定义一个变量,专门记录该节点的层级.然后分析题目的返回值,它是一个子元素是列表的列表,不难发现,子元素的索引,刚好就是数的层级,所以可以直接定义一个列表levels = [],每递归一层,如果大列表中没有该层级的子列表,就往大列表中添加一个字列表,然后往该层级的子列表中添加该节点的值代码如下: 12345678910111213141516171819202122# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def levelOrder(self, root: TreeNode) -&gt; List[List[int]]: levels= [] if not root : return levels def foo(node, level): n = len(levels) if n == level: levels.append([]) levels[level].append(node.val) if node.left: foo(node.left, level + 1) if node.right: foo(node.right, level + 1) foo(root, 0) return levels 1.1 复杂度分析时间复杂度:假设有n个节点,恰好会递归到每一个节点,所以时间复杂度为O(n) 空间复杂度:假设有n个节点,数组存储的刚好是每一个节点,所以空间复杂度为O(n) 2.迭代实现了递归的方式后,迭代的思想节本和递归差不多,只是要加多一个栈的数据结构 12345678910111213141516class Solution: def levelOrder(self, root: TreeNode) -&gt; List[List[int]]: levels = [] stack = [] if not root: return levels stack.append((root, 0)) while stack: node, level = stack.pop() if level == len(levels): levels.append([]) levels[level].append(node.val) if node.right: stack.append((node.right, level + 1)) if node.left: stack.append((node.left, level + 1)) return levels 2.1 复杂度分析时间复杂度：假设有n个节点,恰好会递归到每一个节点,因为每个节点恰好会被运算一次,所以时间复杂度为O(n) 空间复杂度：假设有n个节点,数组存储的刚好是每一个节点,栈的存储也是每一个节点,所以空间复杂度为O(n)+O(n) = O(n) 总结这道题考察的就是树的遍历,和前后序遍历差不错,但是就是加多了一个变量来记录层级,还是那句话,多加练习,多加练习!!!!!!","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://liangweijiang.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"递归","slug":"递归","permalink":"https://liangweijiang.github.io/tags/%E9%80%92%E5%BD%92/"},{"name":"树的遍历","slug":"树的遍历","permalink":"https://liangweijiang.github.io/tags/%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/"}]},{"title":"每日一道算法之--链表反转","slug":"algorithm-206","date":"2020-03-02T10:10:34.816Z","updated":"2020-03-02T10:32:34.192Z","comments":true,"path":"2020/03/02/algorithm-206/","link":"","permalink":"https://liangweijiang.github.io/2020/03/02/algorithm-206/","excerpt":"","text":"反转链表力扣第206题:https://leetcode-cn.com/problems/reverse-linked-list/submissions/ 反转一个单链表。 示例: 输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL 进阶:你可以迭代或递归地反转链表。你能否用两种方法解决这道题？ 1.递归解决1.1 创建新的节点一开始的时候我的想法是,既然是反转链表,那就可以创建一个新的节点来重新存储,然后直接递归到最后的节点,在不断地回溯中将新节点指向回溯的节点. 123456789101112131415161718192021# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: new_node = ListNode(0) n = new_node def reverseList(self, head: ListNode) -&gt; ListNode: if not head:return head def foo(head): if not head.next: return head node = foo(head.next) if node: self.n.next = ListNode(node.val) self.n = self.n.next return head foo(head) self.n.next = ListNode(head.val) return self.new_node.next 在测试了几个例子都行的通,我就很兴奋的提交了,结果哦吼,提交时间超时…… 1.2 在原链表处理我就在找原因,有可能是因为创建了新节点,处理时间太长,能不能不用新的节点,直接在原本的链表中去改变指针的指向,当获取到最后的节点时直接处理该节点 逐步递归,知道获取到最后的节点 递归回退的时候,一次改变节点的指针,使该节点的下下个指针指向自己,即node.next.next = node 注意的是,要将该节点的下一个指针删除,一开始我没注意,看了官方题解才知道 1234567class Solution: def reverseList(self, head: ListNode) -&gt; ListNode: if not head or not head.next: return head node = self.reverseList(head.next) head.next.next = head; head.next = None; return node 1.3 复杂度分析时间复杂度：O(n)，假设 n 是列表的长度，要层层递归,那么时间复杂度为 O(n)。 空间复杂度：O(n)，由于使用递归，将会使用隐式栈空间。递归深度可能会达到 nn 层。 2.迭代实现1.1 用栈实现因为栈是先进先出的数据结构,所以先用栈存储每一个节点,然后在依次取出操作 12345678910111213class Solution: def reverseList(self, head: ListNode) -&gt; ListNode: if not head or not head.next: return head stack = [] while head: stack.append(head) head = head.next n = stack.pop() while stack: node = stack.pop() node.next.next = node node.next = None return n 1.1.1 复杂度分析时间复杂度:假设列表长度为n, 进栈的时间复杂度为O(n),出栈的时间复杂度同样为O(n),所以时间复杂度为2*O(n) = O(n) 空间复杂度为:运用了栈的数据结构,所以空间复杂度为O(n)可以看到效率还是不错的 2.2 官方的双指针解法当我们要反转一个链表时,只需要改变每一个节点的前驱和后继指针 12345678910class Solution: def reverseList(self, head: ListNode) -&gt; ListNode: if not head: return None prev &#x3D; None cur &#x3D; head while cur: cur.next&#x3D; prev prev &#x3D; cur cur &#x3D; cur.next return prev 2.2.1 复杂度分析时间复杂度:O(n) 空间复杂度为:O(n)","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://liangweijiang.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"链表","slug":"链表","permalink":"https://liangweijiang.github.io/tags/%E9%93%BE%E8%A1%A8/"},{"name":"递归","slug":"递归","permalink":"https://liangweijiang.github.io/tags/%E9%80%92%E5%BD%92/"}]},{"title":"每日一道算法之--股票问题总结","slug":"algorithm-stock","date":"2020-03-02T07:31:24.558Z","updated":"2020-03-02T10:32:55.199Z","comments":true,"path":"2020/03/02/algorithm-stock/","link":"","permalink":"https://liangweijiang.github.io/2020/03/02/algorithm-stock/","excerpt":"","text":"股票问题总结最近在leetcode刷题的时候发现了一个很好的解决股票问题的题解,所以收藏了这个链接,他主要运用了状态机的思想,从而非常有效的解决股票等dp问题 文章如下: 本文参考自英文版LeetCode：https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/discuss/108870/Most-consistent-ways-of-dealing-with-the-series-of-stock-problems 很多读者抱怨股票系列问题奇技淫巧太多，如果面试真的遇到这类问题，基本不会想到那些巧妙的办法，怎么办？所以本文拒绝奇技淫巧，而是稳扎稳打，只用一种通用方法解决所用问题，以不变应万变。 这篇文章用状态机的技巧来解决，可以全部提交通过。不要觉得这个名词高大上，文学词汇而已，实际上就是 DP table，看一眼就明白了。 先随便抽出一道题，看看别人的解法： 123456789101112int maxProfit(vector&lt;int&gt;&amp; prices) &#123; if(prices.empty()) return 0; int s1=-prices[0],s2=INT_MIN,s3=INT_MIN,s4=INT_MIN; for(int i=1;i&lt;prices.size();++i) &#123; s1 = max(s1, -prices[i]); s2 = max(s2, s1+prices[i]); s3 = max(s3, s2-prices[i]); s4 = max(s4, s3+prices[i]); &#125; return max(0,s4);&#125; 能看懂吧？会做了吗？不可能的，你看不懂，这才正常。就算你勉强看懂了，下一个问题你还是做不出来。为什么别人能写出这么诡异却又高效的解法呢？因为这类问题是有框架的，但是人家不会告诉你的，因为一旦告诉你，你五分钟就学会了，该算法题就不再神秘，变得不堪一击了。 本文就来告诉你这个框架，然后带着你一道一道秒杀。 这 6 道股票买卖问题是有共性的，我们通过对第四题（限制最大交易次数为 k）的分析一道一道解决。因为第四题是一个最泛化的形式，其他的问题都是这个形式的简化。 第一题是只进行一次交易，相当于 k = 1；第二题是不限交易次数，相当于 k = +infinity（正无穷）；第三题是只进行 2 次交易，相当于 k = 2；剩下两道也是不限次数，但是加了交易「冷冻期」和「手续费」的额外条件，其实就是第二题的变种，都很容易处理。 一、穷举框架首先，还是一样的思路：如何穷举？这里的穷举思路和上篇文章递归的思想不太一样。 递归其实是符合我们思考的逻辑的，一步步推进，遇到无法解决的就丢给递归，一不小心就做出来了，可读性还很好。缺点就是一旦出错，你也不容易找到错误出现的原因。比如上篇文章的递归解法，肯定还有计算冗余，但确实不容易找到。 而这里，我们不用递归思想进行穷举，而是利用「状态」进行穷举。我们具体到每一天，看看总共有几种可能的「状态」，再找出每个「状态」对应的「选择」。我们要穷举所有「状态」，穷举的目的是根据对应的「选择」更新状态。听起来抽象，你只要记住「状态」和「选择」两个词就行，下面实操一下就很容易明白了。 1234for 状态1 in 状态1的所有取值： for 状态2 in 状态2的所有取值： for ... dp[状态1][状态2][...] = 择优(选择1，选择2...) 比如说这个问题，每天都有三种「选择」：买入、卖出、无操作，我们用 buy, sell, rest 表示这三种选择。但问题是，并不是每天都可以任意选择这三种选择的，因为 sell 必须在 buy 之后，buy 必须在 sell 之后。那么 rest 操作还应该分两种状态，一种是 buy 之后的 rest（持有了股票），一种是 sell 之后的 rest（没有持有股票）。而且别忘了，我们还有交易次数 k 的限制，就是说你 buy 还只能在 k &gt; 0 的前提下操作。 很复杂对吧，不要怕，我们现在的目的只是穷举，你有再多的状态，老夫要做的就是一把梭全部列举出来。这个问题的「状态」有三个，第一个是天数，第二个是允许交易的最大次数，第三个是当前的持有状态（即之前说的 rest 的状态，我们不妨用 1 表示持有，0 表示没有持有）。然后我们用一个三维数组就可以装下这几种状态的全部组合： 123456789dp[i][k][0 or 1]0 &lt;= i &lt;= n-1, 1 &lt;= k &lt;= Kn 为天数，大 K 为最多交易数此问题共 n × K × 2 种状态，全部穷举就能搞定。for 0 &lt;= i &lt; n: for 1 &lt;= k &lt;= K: for s in &#123;0, 1&#125;: dp[i][k][s] = max(buy, sell, rest) 而且我们可以用自然语言描述出每一个状态的含义，比如说 dp[3][2][1] 的含义就是：今天是第三天，我现在手上持有着股票，至今最多进行 2 次交易。再比如 dp[2][3][0] 的含义：今天是第二天，我现在手上没有持有股票，至今最多进行 3 次交易。很容易理解，对吧？ 我们想求的最终答案是 dp[n - 1][K][0]，即最后一天，最多允许 K 次交易，最多获得多少利润。读者可能问为什么不是 dp[n - 1][K][1]？因为 [1] 代表手上还持有股票，[0] 表示手上的股票已经卖出去了，很显然后者得到的利润一定大于前者。 记住如何解释「状态」，一旦你觉得哪里不好理解，把它翻译成自然语言就容易理解了。 二、状态转移框架现在，我们完成了「状态」的穷举，我们开始思考每种「状态」有哪些「选择」，应该如何更新「状态」。只看「持有状态」，可以画个状态转移图。 123456789101112131415通过这个图可以很清楚地看到，每种状态（0 和 1）是如何转移而来的。根据这个图，我们来写一下状态转移方程：dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]) max( 选择 rest , 选择 sell )解释：今天我没有持有股票，有两种可能：要么是我昨天就没有持有，然后今天选择 rest，所以我今天还是没有持有；要么是我昨天持有股票，但是今天我 sell 了，所以我今天没有持有股票了。dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]) max( 选择 rest , 选择 buy )解释：今天我持有着股票，有两种可能：要么我昨天就持有着股票，然后今天选择 rest，所以我今天还持有着股票；要么我昨天本没有持有，但今天我选择 buy，所以今天我就持有股票了。 这个解释应该很清楚了，如果 buy，就要从利润中减去 prices[i]，如果 sell，就要给利润增加 prices[i]。今天的最大利润就是这两种可能选择中较大的那个。而且注意 k 的限制，我们在选择 buy 的时候，把 k 减小了 1，很好理解吧，当然你也可以在 sell 的时候减 1，一样的。 现在，我们已经完成了动态规划中最困难的一步：状态转移方程。如果之前的内容你都可以理解，那么你已经可以秒杀所有问题了，只要套这个框架就行了。不过还差最后一点点，就是定义 base case，即最简单的情况。 12345678dp[-1][k][0] = 0解释：因为 i 是从 0 开始的，所以 i = -1 意味着还没有开始，这时候的利润当然是 0 。dp[-1][k][1] = -infinity解释：还没开始的时候，是不可能持有股票的，用负无穷表示这种不可能。dp[i][0][0] = 0解释：因为 k 是从 1 开始的，所以 k = 0 意味着根本不允许交易，这时候利润当然是 0 。dp[i][0][1] = -infinity解释：不允许交易的情况下，是不可能持有股票的，用负无穷表示这种不可能。 把上面的状态转移方程总结一下： 12345678base case：dp[-1][k][0] = dp[i][0][0] = 0dp[-1][k][1] = dp[i][0][1] = -infinity状态转移方程：dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])读者可能会问，这个数组索引是 -1 怎么编程表示出来呢，负无穷怎么表示呢？这都是细节问题，有很多方法实现。现在完整的框架已经完成，下面开始具体化。 三、秒杀题目第一题，k = 1直接套状态转移方程，根据 base case，可以做一些化简： 123456789dp[i][1][0] = max(dp[i-1][1][0], dp[i-1][1][1] + prices[i])dp[i][1][1] = max(dp[i-1][1][1], dp[i-1][0][0] - prices[i]) = max(dp[i-1][1][1], -prices[i])解释：k = 0 的 base case，所以 dp[i-1][0][0] = 0。现在发现 k 都是 1，不会改变，即 k 对状态转移已经没有影响了。可以进行进一步化简去掉所有 k：dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])dp[i][1] = max(dp[i-1][1], -prices[i]) 直接写出代码： 1234567int n = prices.length;int[][] dp = new int[n][2];for (int i = 0; i &lt; n; i++) &#123; dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1] + prices[i]); dp[i][1] = Math.max(dp[i-1][1], -prices[i]);&#125;return dp[n - 1][0]; 显然 i = 0 时 dp[i-1] 是不合法的。这是因为我们没有对 i 的 base case 进行处理。可以这样处理： 12345678910111213141516171819for (int i = 0; i &lt; n; i++) &#123; if (i - 1 == -1) &#123; dp[i][0] = 0; // 解释： // dp[i][0] // = max(dp[-1][0], dp[-1][1] + prices[i]) // = max(0, -infinity + prices[i]) = 0 dp[i][1] = -prices[i]; //解释： // dp[i][1] // = max(dp[-1][1], dp[-1][0] - prices[i]) // = max(-infinity, 0 - prices[i]) // = -prices[i] continue; &#125; dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1] + prices[i]); dp[i][1] = Math.max(dp[i-1][1], -prices[i]);&#125;return dp[n - 1][0]; 第一题就解决了，但是这样处理 base case 很麻烦，而且注意一下状态转移方程，新状态只和相邻的一个状态有关，其实不用整个 dp 数组，只需要一个变量储存相邻的那个状态就足够了，这样可以把空间复杂度降到 O(1): 12345678910111213// k == 1int maxProfit_k_1(int[] prices) &#123; int n = prices.length; // base case: dp[-1][0] = 0, dp[-1][1] = -infinity int dp_i_0 = 0, dp_i_1 = Integer.MIN_VALUE; for (int i = 0; i &lt; n; i++) &#123; // dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i]) dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]); // dp[i][1] = max(dp[i-1][1], -prices[i]) dp_i_1 = Math.max(dp_i_1, -prices[i]); &#125; return dp_i_0;&#125; 两种方式都是一样的，不过这种编程方法简洁很多。但是如果没有前面状态转移方程的引导，是肯定看不懂的。后续的题目，我主要写这种空间复杂度 O(1) 的解法。 第二题，k = +infinity如果 k 为正无穷，那么就可以认为 k 和 k - 1 是一样的。可以这样改写框架： 1234567dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]) = max(dp[i-1][k][1], dp[i-1][k][0] - prices[i])我们发现数组中的 k 已经不会改变了，也就是说不需要记录 k 这个状态了：dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i]) 直接翻译成代码： 12345678910int maxProfit_k_inf(int[] prices) &#123; int n = prices.length; int dp_i_0 = 0, dp_i_1 = Integer.MIN_VALUE; for (int i = 0; i &lt; n; i++) &#123; int temp = dp_i_0; dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]); dp_i_1 = Math.max(dp_i_1, temp - prices[i]); &#125; return dp_i_0;&#125; 第三题，k = +infinity with cooldown每次 sell 之后要等一天才能继续交易。只要把这个特点融入上一题的状态转移方程即可： 1234567891011121314151617dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])dp[i][1] = max(dp[i-1][1], dp[i-2][0] - prices[i])解释：第 i 天选择 buy 的时候，要从 i-2 的状态转移，而不是 i-1 。翻译成代码：int maxProfit_with_cool(int[] prices) &#123; int n = prices.length; int dp_i_0 = 0, dp_i_1 = Integer.MIN_VALUE; int dp_pre_0 = 0; // 代表 dp[i-2][0] for (int i = 0; i &lt; n; i++) &#123; int temp = dp_i_0; dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]); dp_i_1 = Math.max(dp_i_1, dp_pre_0 - prices[i]); dp_pre_0 = temp; &#125; return dp_i_0;&#125; 第四题，k = +infinity with fee每次交易要支付手续费，只要把手续费从利润中减去即可。改写方程： 12345678910111213141516dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i] - fee)解释：相当于买入股票的价格升高了。在第一个式子里减也是一样的，相当于卖出股票的价格减小了。直接翻译成代码：int maxProfit_with_fee(int[] prices, int fee) &#123; int n = prices.length; int dp_i_0 = 0, dp_i_1 = Integer.MIN_VALUE; for (int i = 0; i &lt; n; i++) &#123; int temp = dp_i_0; dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]); dp_i_1 = Math.max(dp_i_1, temp - prices[i] - fee); &#125; return dp_i_0;&#125; 第五题，k = 2k = 2 和前面题目的情况稍微不同，因为上面的情况都和 k 的关系不太大。要么 k 是正无穷，状态转移和 k 没关系了；要么 k = 1，跟 k = 0 这个 base case 挨得近，最后也没有存在感。 这道题 k = 2 和后面要讲的 k 是任意正整数的情况中，对 k 的处理就凸显出来了。我们直接写代码，边写边分析原因。 原始的动态转移方程，没有可化简的地方 12dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]) 按照之前的代码，我们可能想当然这样写代码（错误的）： 12345678int k = 2;int[][][] dp = new int[n][k + 1][2];for (int i = 0; i &lt; n; i++) if (i - 1 == -1) &#123; /* 处理一下 base case*/ &#125; dp[i][k][0] = Math.max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]); dp[i][k][1] = Math.max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]);&#125;return dp[n - 1][k][0]; 为什么错误？我这不是照着状态转移方程写的吗？ 还记得前面总结的「穷举框架」吗？就是说我们必须穷举所有状态。其实我们之前的解法，都在穷举所有状态，只是之前的题目中 k 都被化简掉了。这道题由于没有消掉 k 的影响，所以必须要对 k 进行穷举： 12345678910111213141516int max_k = 2;int[][][] dp = new int[n][max_k + 1][2];for (int i = 0; i &lt; n; i++) &#123; for (int k = max_k; k &gt;= 1; k--) &#123; if (i - 1 == -1) &#123; /* 处理 base case */ dp[i][k][0] = 0; dp[i][k][1] = -prices[i]; continue; &#125; dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]); dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]); &#125;&#125;// 穷举了 n × max_k × 2 个状态，正确。return dp[n - 1][max_k][0]; 如果你不理解，可以返回第一点「穷举框架」重新阅读体会一下。 这里 k 取值范围比较小，所以可以不用 for 循环，直接把 k = 1 和 2 的情况手动列举出来也可以： 12345678910111213141516dp[i][2][0] = max(dp[i-1][2][0], dp[i-1][2][1] + prices[i])dp[i][2][1] = max(dp[i-1][2][1], dp[i-1][1][0] - prices[i])dp[i][1][0] = max(dp[i-1][1][0], dp[i-1][1][1] + prices[i])dp[i][1][1] = max(dp[i-1][1][1], -prices[i])int maxProfit_k_2(int[] prices) &#123; int dp_i10 = 0, dp_i11 = Integer.MIN_VALUE; int dp_i20 = 0, dp_i21 = Integer.MIN_VALUE; for (int price : prices) &#123; dp_i20 = Math.max(dp_i20, dp_i21 + price); dp_i21 = Math.max(dp_i21, dp_i10 - price); dp_i10 = Math.max(dp_i10, dp_i11 + price); dp_i11 = Math.max(dp_i11, -price); &#125; return dp_i20;&#125; 有状态转移方程和含义明确的变量名指导，相信你很容易看懂。其实我们可以故弄玄虚，把上述四个变量换成 a, b, c, d。这样当别人看到你的代码时就会一头雾水，大惊失色，不得不对你肃然起敬。 第六题，k = any integer有了上一题 k = 2 的铺垫，这题应该和上一题的第一个解法没啥区别。但是出现了一个超内存的错误，原来是传入的 k 值会非常大，dp 数组太大了。现在想想，交易次数 k 最多有多大呢？ 一次交易由买入和卖出构成，至少需要两天。所以说有效的限制 k 应该不超过 n/2，如果超过，就没有约束作用了，相当于 k = +infinity。这种情况是之前解决过的。 直接把之前的代码重用： 12345678910111213141516171819int maxProfit_k_any(int max_k, int[] prices) &#123; int n = prices.length; if (max_k &gt; n / 2) return maxProfit_k_inf(prices); int[][][] dp = new int[n][max_k + 1][2]; for (int i = 0; i &lt; n; i++) for (int k = max_k; k &gt;= 1; k--) &#123; if (i - 1 == -1) &#123; /* 处理 base case */ dp[i][k][0] = 0; dp[i][k][1] = -prices[i]; continue; &#125; dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]); dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]); &#125; return dp[n - 1][max_k][0];&#125; 至此，6 道题目通过一个状态转移方程全部解决。 四、最后总结本文给大家讲了如何通过状态转移的方法解决复杂的问题，用一个状态转移方程秒杀了 6 道股票买卖问题，现在想想，其实也不算难对吧？这已经属于动态规划问题中较困难的了。 关键就在于列举出所有可能的「状态」，然后想想怎么穷举更新这些「状态」。一般用一个多维 dp 数组储存这些状态，从 base case 开始向后推进，推进到最后的状态，就是我们想要的答案。想想这个过程，你是不是有点理解「动态规划」这个名词的意义了呢？ 具体到股票买卖问题，我们发现了三个状态，使用了一个三维数组，无非还是穷举 + 更新，不过我们可以说的高大上一点，这叫「三维 DP」，怕不怕？这个大实话一说，立刻显得你高人一等，名利双收有没有。 所以，大家不要被各种高大上的名词吓到，再多的困难问题，奇技淫巧，也不过是基本套路的不断升级组合产生的。只要把住算法的底层原理，即可举一反三，逐个击破。 买卖股票的最佳时机 买卖股票的最佳时机 II 买卖股票的最佳时机 III 买卖股票的最佳时机 IV 最佳买卖股票时机含冷冻期 买卖股票的最佳时机含手续费 作者：labuladong链接：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/solution/yi-ge-fang-fa-tuan-mie-6-dao-gu-piao-wen-ti-by-l-3/来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://liangweijiang.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://liangweijiang.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"状态机","slug":"状态机","permalink":"https://liangweijiang.github.io/tags/%E7%8A%B6%E6%80%81%E6%9C%BA/"}]},{"title":"每日一道算法之--无重复的最长的子字符串","slug":"algorithm-3","date":"2020-02-29T08:59:16.674Z","updated":"2020-02-29T09:00:09.921Z","comments":true,"path":"2020/02/29/algorithm-3/","link":"","permalink":"https://liangweijiang.github.io/2020/02/29/algorithm-3/","excerpt":"","text":"无重复的最长的子字符串力扣第3题:https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/ 1 暴力解决暴力方法就是将所有的肯恩列举出来,在会超过时间限制,这里就不列举了 2 滑动窗口这道题是我第一道碰到的滑动窗口的题目,当时想了很久都想不出来,后来去看一一下别人的题解恍然大悟,滑动窗口确实是解决字符串问题的一非常好的方法 滑动窗口的顾名思义就是可以滑动的数据结构,遍历整个字符串,当滑动窗口里没有该字符时,就将该字符加进滑动窗口 当遇到有重复字符时,要将滑动窗口该字符前面的的字符(包括该字符)全部去除,然后在将该字符加进滑动窗口 代码如下: 1234567891011121314151617181920class Solution: def lengthOfLongestSubstring(self, s: str) -&gt; int: # 集合可以保证唯一性 silde_win = set() # 设置滑动窗口的值 left = 0 # 记录最长子串的长度 max_len = 0 # 记录当前的子串长度 cur_len = 0 for i in range(len(s)): cur_len += 1 # 设置滑动窗口的值 while s[i] in silde_win: silde_win.remove(s[left]) left += 1 cur_len -= 1 silde_win.add(s[i]) max_len = max(max_len, cur_len) return max_len 2.1 复杂度分析时间复杂度:遍历了一次数组,时间复杂度为$$0(N)$$, 但是每次滑动窗口的都有重复字符,如字符串为’aaaaaaaaaaaaaaaaaaa’,会浪费没必要的时间,但是均摊时间复杂度依然为$$O(N)$$ 空间复杂度:用了集合,所以空间复杂度为$$O(N)$$ 滑动窗口的优化可以看到提交的成绩不是很理想,所以我一直在想着怎么优化,想到了几个优化方法 如果字符串有相邻的子串,直接忽视123456789101112131415161718192021222324class Solution: def lengthOfLongestSubstring(self, s: str) -&gt; int: if not s :return 0 silde_win = set() left = 0 max_len = 0 cur_len = 0 for i in range(len(s)): # 如果字符串有相邻的子串,直接忽视 if i &gt; 0 and s[i-1] == s[i]: silde_win = set() silde_win.add(s[i]) left = i cur_len = 1 continue cur_len += 1 # 设置滑动窗口的值 while s[i] in silde_win: silde_win.remove(s[left]) left += 1 cur_len -= 1 silde_win.add(s[i]) max_len = max(max_len, cur_len) return max_len 可以发现成绩有了提升,但不是很明显 然后在看看我么你写的代码,silde_win这个数据结构其实是有很多操作的,话费了很多时间,换个思路想一想,我们能又能用更好地数据结构来代替这个集合呢,其实这个滑动窗口只是一个辅助的数据结构,只是用来暂时存储字符串的字串的,那为什么不直接用分片呢 123456789101112131415161718192021class Solution: def lengthOfLongestSubstring(self, s: str) -&gt; int: if not s :return 0 # 设置滑动窗口的值 left = 0 # 记录最长子串的长度 max_len = 0 # 记录当前的子串长度 cur_len = 0 for i in range(len(s)): if i &gt; 0 and s[i-1] == s[i]: left = i cur_len = 1 continue cur_len += 1 # 设置滑动窗口的值 while s[i] in s[left:i]: left += 1 cur_len -= 1 max_len = max(max_len, cur_len) return max_len 只能优化到这种程度了,再去看看别人的题解拓展一下","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://liangweijiang.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"滑动窗口","slug":"滑动窗口","permalink":"https://liangweijiang.github.io/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"}]},{"title":"每日一道算法之--买卖股票的最佳时机","slug":"algorithm-121","date":"2020-02-29T07:25:08.775Z","updated":"2020-03-02T10:29:59.799Z","comments":true,"path":"2020/02/29/algorithm-121/","link":"","permalink":"https://liangweijiang.github.io/2020/02/29/algorithm-121/","excerpt":"","text":"买卖股票的最佳时机力扣第121题：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。 如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。 注意你不能在买入股票前卖出股票。 示例 1: 输入: [7,1,5,3,6,4]输出: 5解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。 注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。 示例 2： 输入: [7,6,4,3,1]输出: 0解释: 在这种情况下, 没有交易完成, 所以最大利润为 0 1 暴力方法暴力方法简单容易理解，只是两次循环把所有的可能一一列举出来。然后在取其中的最大值 12345678class Solution: def maxProfit(self, prices: List[int]) -&gt; int: max_profit = 0 for i in range(len(prices) - 1): for j in range(i + 1, len(prices)): profit = prices[j] - prices[i] max_profit = max(max_profit, profit) return max_profit 1.1 复杂度分析时间复杂度:循环里嵌套另一个循环,所里时间复杂度为$$O(N^2)$$ 空间复杂度:只使用了max_profit和profit两个变量,所以空间复杂度为$$O(1)$$ 2 动态规划遍历一次 由题意不难理解,当前最大的收益就是你当前的价格减去之前的最小价格,所以定义一个变量min_price存储之前的最小值,在定义一个变量max_profit存储最大的收益值,便可以达到遍历一次 状态转移方程为dp[i] = max(dp[i-1]+diff[i], 0), dp[i])指以i元素结尾的子数组的最大和 12345678class Solution: def maxProfit(self, prices: List[int]) -&gt; int: min_price = float('inf') max_profit = 0 for i in range(len(prices)): min_price = min(prices[i], min_price) max_profit = max(max_profit, prices[i]-min_price) return max_profit 2.1 复杂度分析时间复杂度:遍历了一次数组,所以时间复杂度为$$O(N)$$ 空间复杂度:只使用了min_price和max_profit两个变量,所以空间复杂度为$$O(1)$$","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://liangweijiang.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://liangweijiang.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"DRF源码解析6--权限组件的封装和初始化","slug":"DRF-06","date":"2020-02-26T09:55:17.825Z","updated":"2020-02-26T09:56:50.508Z","comments":true,"path":"2020/02/26/DRF-06/","link":"","permalink":"https://liangweijiang.github.io/2020/02/26/DRF-06/","excerpt":"","text":"1.权限组件的初始化在前面的版本控制和认证组件里提到的initia初始化函数, 同时也对权限组件进行了初始化 1234567def initial(self, request, *args, **kwargs): # 认证组件 self.perform_authentication(request) # 权限组件 self.check_permissions(request) # 频率 self.check_throttles(request) 1.1 check_permissions可以看到,check_permissions函数就是初始化权限组件的函数了 123456789 def check_permissions(self, request): for permission in self.get_permissions():# permission_denied函数抛出异常# 说明权限组件中必须包含has_permission的方法# 同时说明这是DRF框架给我们提供的自定义权限组件的钩子 if not permission.has_permission(request, self): self.permission_denied( request, message=getattr(permission, 'message', None) ) 1.2 get_permissions可以看出,权限组件在self.get_permissions方法中获取 12def get_permissions(self): return [permission() for permission in self.permission_classes] 可以看到,这个和认证组件的获取方法是一样的,只是没有认证组件那么绕 2. 权限组件的类型DRF提供的权限组件在rest_framework.permissions中,如下图可以看到, has_permission方法返回的是布尔类型 #总结DRF的权限组件比较简单,和认证组件大致一样","categories":[{"name":"django-rest-framework","slug":"django-rest-framework","permalink":"https://liangweijiang.github.io/categories/django-rest-framework/"}],"tags":[{"name":"DRF","slug":"DRF","permalink":"https://liangweijiang.github.io/tags/DRF/"}]},{"title":"每日一道算法之--乘积最大子序和","slug":"algorithm-152","date":"2020-02-26T09:08:00.357Z","updated":"2020-03-02T10:32:21.176Z","comments":true,"path":"2020/02/26/algorithm-152/","link":"","permalink":"https://liangweijiang.github.io/2020/02/26/algorithm-152/","excerpt":"","text":"乘积最大子序和力扣第152题:https://leetcode-cn.com/problems/maximum-product-subarray/给定一个整数数组 nums ，找出一个序列中乘积最大的连续子序列（该序列至少包含一个数）。 示例 1: 输入: [2,3,-2,4]输出: 6解释: 子数组 [2,3] 有最大乘积 6。 示例 2: 输入: [-2,0,-1]输出: 0解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。 1. 类似指针的解法参考力扣第53题最大子序和的其中一种双指针解法,这道题同样可以用类似指针的解法 首先定义一个res记录最大的子序和,cur_pos记录当前的乘积 然后cur_pos依次累乘, 每一次的结果都有三种情况: cur_pos等于0, 这时候要重新将指针偏移后一位 cur_pos大于0, 这时候要更新res的结果,就是和cur_pos比较大小 cur_pos小于0, 负负得正,需要找到指针前面最大的负数,相除就变为最大 12345678910111213141516171819202122232425262728class Solution: def maxProduct(self, nums: List[int]) -&gt; int: if not nums: return 0 # 目前的累乘 cur_pro = 1 # 前面最大的负数 max_neg = float(\"-inf\") # 结果 res = float(\"-inf\") for num in nums: cur_pro *= num # 考虑三种情况 # 大于0 if cur_pro &gt; 0: res = max(res, cur_pro) # 小于0 elif cur_pro &lt; 0: if max_neg != float(\"-inf\"): res = max(res, cur_pro // max_neg) else: res = max(res, num) max_neg = max(max_neg, cur_pro) # 等于0 else: cur_pro = 1 max_neg = float(\"-inf\") res = max(res, num) return res 1.1 复杂度分析时间复杂度:遍历整个数组的时间复杂度为O(N)空间复杂度:没有用到额外的数据结构,所以空间复杂度为O(1) 2. 动态规划解决不难发现,每一个元素的乘积,最大值只可能在自身或者自身与上一次的累乘之中公式如下: dp_max[i] = Math.max(nums[i-1],dp_max[i-1]*nums[i-1]) 因为存在负数,所以当这个元素为负数是,其最大乘积可能是与上一次最小乘积相乘所以不仅要定义一个变量存储最大当前的最大累乘,还要定义一个变量存储当前的最小累乘 12345678910111213141516class Solution: def maxProduct(self, nums: List[int]) -&gt; int: if not nums: return 0 # 存储最后的结果 res = nums[0] # 存储最大当前的最大累乘 res_max = nums[0] # 存储当前的最小累乘 res_min = nums[0] for num in nums[1:]: cur_max = max(res_max*num, res_min*num, num) cur_min = min(res_max*num, res_min*num, num) res = max(res, cur_max) res_max = cur_max res_min = cur_min return res 2.1 复杂度分析时间复杂度:遍历整个数组的时间复杂度为O(N)空间复杂度:没有用到额外的数据结构,所以空间复杂度为O(1)","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://liangweijiang.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://liangweijiang.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"指针","slug":"指针","permalink":"https://liangweijiang.github.io/tags/%E6%8C%87%E9%92%88/"}]},{"title":"DRF源码解析5--认证组件的封装和初始化","slug":"DRF-05","date":"2020-02-24T12:59:20.730Z","updated":"2020-02-26T09:41:53.685Z","comments":true,"path":"2020/02/24/DRF-05/","link":"","permalink":"https://liangweijiang.github.io/2020/02/24/DRF-05/","excerpt":"","text":"1.认证组件的初始化在对DRF的版本认证里说到,initial()不仅对版本认证组件进行了初始化,同时还初始化了认证组件,现在来分析一下DRF是怎么样初始化认证方法的 12def perform_authentication(self, request): request.user 可以看到,perform_authentication()方法返回了request(相当于封装的Request),进入request中找到uesr方法 1.1 截取Request部分代码如下:123456789101112131415161718192021222324252627class Request: def __init__(self, request, parsers=None, authenticators=None, negotiator=None, parser_context=None): assert isinstance(request, HttpRequest), ( 'The `request` argument must be an instance of ' '`django.http.HttpRequest`, not `&#123;&#125;.&#123;&#125;`.' .format(request.__class__.__module__, request.__class__.__name__) ) self._request = request self.parsers = parsers or () self.authenticators = authenticators or () self.negotiator = negotiator or self._default_negotiator() @property def user(self): if not hasattr(self, '_user'): with wrap_attributeerrors(): self._authenticate() return self._user @user.setter def user(self, value): # 当调用user时触发, 如user = 'xxx', 则value = 'xxx' self._user = value self._request.user = value 可以看到,user执行了self._authenticate方法,返回的_user为当前用户 截取self._authenticate的代码如下:12345678910111213 def _authenticate(self): for authenticator in self.authenticators: try:# 这里是调用默认的认证组件里的authenticate方法 user_auth_tuple = authenticator.authenticate(self) except exceptions.APIException: self._not_authenticated() raise if user_auth_tuple is not None: self._authenticator = authenticator self.user, self.auth = user_auth_tuple return self.authenticators为Request的属性,所以在init中可以找到 123def __init__(self, request, parsers=None, authenticators=None, negotiator=None, parser_context=None): self.authenticators = authenticators or () authenticators是作为参数传进来的,所以回到实例化Request的initialize_request方法中 12345678910def initialize_request(self, request, *args, **kwargs): parser_context = self.get_parser_context(request) return Request( request, parsers=self.get_parsers(), authenticators=self.get_authenticators(), negotiator=self.get_content_negotiator(), parser_context=parser_context ) 可以看到,authenticators传进了一个self.get_authenticators的方法 1.2 截取self.get_authenticators代码如下12def get_authenticators(self): return [auth() for auth in self.authentication_classes] 可以看到,get_authenticators方法返回了self.authentication_classes中所有auth的执行结果的一个列表, 而self.authentication_classes则为DRF中默认的认证组件 authenticate回到_authenticate方法中,现在已经知道authenticator是DRF默认的认证组件,则进去其authenticate方法中 12345678class ForcedAuthentication: def __init__(self, force_user, force_token): self.force_user = force_user self.force_token = force_token def authenticate(self, request): return (self.force_user, self.force_token) 其返回了self.force_user, self.force_token,分别为用户和验证用户信息的的token码,说明了认证组件都带有authenticate方法并且返回用户认证的信息 1.3 思路总结DRF认证组件的初始化主要分为两部分: 2. 认证组件的类型DRF提供的认证组件在rest_framework.authentication中 2.1 BaseAuthentication1234567class BaseAuthentication: def authenticate(self, request): raise NotImplementedError(\".authenticate() must be overridden.\") def authenticate_header(self, request): pass 可以看出,authenticate方法就是自定制认证组件的钩子函数 2.2 SessionAuthentication1234567891011121314151617181920212223242526class SessionAuthentication(BaseAuthentication): def authenticate(self, request): # 重写了authenticate方法并获取当前的用户信息 # Get the session-based user from the underlying HttpRequest object user = getattr(request._request, 'user', None) # Unauthenticated, CSRF validation not required if not user or not user.is_active: return None # 执行enforce_csrf方法判断用户的csrf_token是否正确 self.enforce_csrf(request) # CSRF passed with authenticated user return (user, None) def enforce_csrf(self, request): check = CSRFCheck() # populates request.META['CSRF_COOKIE'], which is used in process_view() # 中间件的process_request方法,拿取用户的CSRF_COOKIE check.process_request(request) # 认证用户的CSRF_COOKIE是否正确 reason = check.process_view(request, None, (), &#123;&#125;) if reason: # CSRF failed, bail with explicit error message raise exceptions.PermissionDenied('CSRF Failed: %s' % reason) 总结DRF的认证组件就是通过中间件等方法,获取当前用户的认证信息,在与本地的信息进行对比,从而达到认证用户的目的。","categories":[{"name":"django-rest-framework","slug":"django-rest-framework","permalink":"https://liangweijiang.github.io/categories/django-rest-framework/"}],"tags":[{"name":"DRF","slug":"DRF","permalink":"https://liangweijiang.github.io/tags/DRF/"}]},{"title":"每日一道算法之--三数之和","slug":"algorithm-15","date":"2020-02-24T09:25:51.544Z","updated":"2020-03-02T10:30:37.376Z","comments":true,"path":"2020/02/24/algorithm-15/","link":"","permalink":"https://liangweijiang.github.io/2020/02/24/algorithm-15/","excerpt":"","text":"三数之和力扣第15题：https://leetcode-cn.com/problems/3sum/给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。 注意：答案中不可以包含重复的三元组。 示例： 给定数组 nums = [-1, 0, 1, 2, -1, -4]，满足要求的三元组集合为：[ [-1, 0, 1], [-1, -1, 2]] 1. 排序 + 双指针解法题目中的要求是不能含有相同的三元组，所以在算法中我们需要去重，排序是一个很好的方法，因为排序可以让相同的数连载一起，方便判断去重。让后在通过双指针对数组一一检查，找到所有合适的三元组。 1234567891011121314151617181920212223242526272829class Solution: def threeSum(self, nums: List[int]) -&gt; List[List[int]]: # 先将nums排序 nums.sort() res = [] for i in range(len(nums) - 2): # 设置两个指针 l, r = i + 1, len(nums) - 1 if nums[i] &gt; 0 : return res # 去除重复的判断,因为nums[i -1]已经包含了nums[i]的所有组合的可能性 if i &gt; 0 and nums[i] == nums[i - 1] : continue while l &lt; r: s = nums[i] + nums[l] + nums[r] if s &lt; 0: # 如果和小于0，证明左边的数太小了，需要往后移 l += 1 # 去除重复的判断，但是前提条件为l&lt;r while l &lt; r and nums[l] == nums[l - 1]: l += 1 elif s &gt; 0: r -= 1 # 如果和大于0，证明右边的数太大了，需要往前移 while l &lt; r and nums[r] == nums[r + 1]: r -= 1 else: res.append([nums[i], nums[l], nums[r]]) l += 1 r -= 1 while l &lt; r and nums[l] == nums[l - 1]: l += 1 while l &lt; r and nums[r] == nums[r + 1]: r -= 1 return res 1.1 时间复杂度分析 时间复杂度：排序的时间复杂度为 O(NlogN), 遍历数组为O(N),双指针的遍历为O(N),所以总的时间复杂度为$$O(NlogN)+0(N)*O(N) = O(N^2)$$ 空间复杂度：没有用到额外的数据结构，所以空间复杂度为$$O(1)$$ 2.哈希索引的方法（空间换时间）参考两数之和，我们可以构建哈希表的方法使查找效率变得更高。 12345678910111213141516171819202122232425262728class Solution: def threeSum(self, nums: List[int]) -&gt; List[List[int]]: if len(nums) &lt; 3: return [] nums.sort() # 因为a+b = 0等价于a = -b target_hash = &#123;-x: i for i, x in enumerate(nums)&#125; res = [] res_hash = &#123;&#125; # 从零开始检索,到倒数第二位结束 for i, first in enumerate(nums[:-1]): if nums[i] &gt; 0: return res if i &gt; 0 and first == nums[i - 1]: continue #从第一个指针的下一位开始搜索 for j, second in enumerate(nums[i + 1:]): # 检查两数之和是否存在于哈希表target_hash中 if first + second in target_hash: target_index = target_hash[first + second] if target_index == i or target_index == i + j + 1: continue # 将找到的结果存入另一个哈希表中, 避免包含重复结果 row = sorted([first, second, nums[target_index]]) key = \",\".join([str(x) for x in row]) if key not in res_hash: res.append(row) res_hash[key] = True return res","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://liangweijiang.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"双指针","slug":"双指针","permalink":"https://liangweijiang.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"哈希表","slug":"哈希表","permalink":"https://liangweijiang.github.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"},{"name":"排序","slug":"排序","permalink":"https://liangweijiang.github.io/tags/%E6%8E%92%E5%BA%8F/"}]},{"title":"DRF源码解析4--版本控制组件的封装","slug":"DRF-04","date":"2020-02-22T14:09:24.712Z","updated":"2020-02-22T14:11:09.294Z","comments":true,"path":"2020/02/22/DRF-04/","link":"","permalink":"https://liangweijiang.github.io/2020/02/22/DRF-04/","excerpt":"","text":"一.DRF中APIView的initial()方法初始化版本信息在讲到DRF对ruquest的封装时,返回新封装的Request后,DRF执行了initial()方法对组件的初始化 12345678910111213def initial(self, request, *args, **kwargs): # 版本控制组件 version, scheme = self.determine_version(request, *args, **kwargs) # 将版本空值信息写入request中 request.version, request.versioning_scheme = version, scheme # Ensure that the incoming request is permitted # 认证组件 self.perform_authentication(request) # 权限组件 self.check_permissions(request) # 频率 self.check_throttles(request) 1.1重写determine_version()自定制版本信息12345678910 def determine_version(self, request, *args, **kwargs): \"\"\" If versioning is being used, then determine any API version for the incoming request. Returns a two-tuple of (version, versioning_scheme) \"\"\" if self.versioning_class is None: return (None, None)# self.versioning_class是drf配置默认的类,说明我们自定义版本时要重写这个方法 scheme = self.versioning_class() return (scheme.determine_version(request, *args, **kwargs), scheme) 二.rest_framework.versioning提供的版本控制方法 2.1 BaseVersioning1234567891011121314151617181920212223class BaseVersioning: # default_version(None), allowed_versions(None), version_param可以在settings中重新配置 default_version = api_settings.DEFAULT_VERSION allowed_versions = api_settings.ALLOWED_VERSIONS version_param = api_settings.VERSION_PARAM def determine_version(self, request, *args, **kwargs): # 在继承该类时要重写determine_version(方法) msg = '&#123;cls&#125;.determine_version() must be implemented.' raise NotImplementedError(msg.format( cls=self.__class__.__name__ )) def reverse(self, viewname, args=None, kwargs=None, request=None, format=None, **extra): # 和django.urls.reverse大致相同, # 但可以选择接受一个请求并返回使用请求获取基本URL的标准URL。 return _reverse(viewname, args, kwargs, request, format, **extra) def is_allowed_version(self, version): if not self.allowed_versions: return True return ((version is not None and version == self.default_version) or (version in self.allowed_versions)) 2.2 URLPathVersioning1234567891011121314151617181920212223242526272829303132333435363738class URLPathVersioning(BaseVersioning): \"\"\" To the client this is the same style as `NamespaceVersioning`. The difference is in the backend - this implementation uses Django's URL keyword arguments to determine the version. An example URL conf for two views that accept two different versions. 可以看到版本信息就在url中 urlpatterns = [ url(r'^(?P&lt;version&gt;[v1|v2]+)/users/$', users_list, name='users-list'), url(r'^(?P&lt;version&gt;[v1|v2]+)/users/(?P&lt;pk&gt;[0-9]+)/$', users_detail, name='users-detail') ] GET /1.0/something/ HTTP/1.1 Host: example.com Accept: application/json \"\"\" invalid_version_message = _('Invalid version in URL path.') def determine_version(self, request, *args, **kwargs): # self.version_param,self.default_version是父类中的属性,可以自定义 version = kwargs.get(self.version_param, self.default_version) if version is None: # 如果没有自己配置默认为DRF默认的版本信息 version = self.default_version if not self.is_allowed_version(version): raise exceptions.NotFound(self.invalid_version_message) return version def reverse(self, viewname, args=None, kwargs=None, request=None, format=None, **extra): if request.version is not None: kwargs = &#123;&#125; if (kwargs is None) else kwargs # self.version_param就是版本的key kwargs[self.version_param] = request.version return super().reverse( viewname, args, kwargs, request, format, **extra 其他的类基本配置都差不多","categories":[{"name":"django-rest-framework","slug":"django-rest-framework","permalink":"https://liangweijiang.github.io/categories/django-rest-framework/"}],"tags":[{"name":"DRF","slug":"DRF","permalink":"https://liangweijiang.github.io/tags/DRF/"}]},{"title":"DRF源码解析3--routers对路由的封装","slug":"DRF-03","date":"2020-02-20T15:15:11.102Z","updated":"2020-02-20T15:16:50.088Z","comments":true,"path":"2020/02/20/DRF-03/","link":"","permalink":"https://liangweijiang.github.io/2020/02/20/DRF-03/","excerpt":"","text":"当我们想最方便的使用drf的路由的时候,只需要用DefaultRoute实例化一个路由实例,然后注册,再讲注册后的组件加入urlpatterns即可 123456from rest_framework.routers import DefaultRouterrouter = DefaultRouter()# 其中BookModelView继承了viewsets.ModelViewSetrouter.register(r'^book', views.BookModelView)urlpatterns += router.urls 到底routers底层是怎么样实现的呢 routersDefaultRoute是routers组件里的一个类,相当于帮助我们在路由里构建好了如{‘list’:”create”}的对应关系,它继承了SimpleRouter,截取源码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102class SimpleRouter(BaseRouter): routes = [ # List route. Route( url=r'^&#123;prefix&#125;&#123;trailing_slash&#125;$', # 这里构建好了对应关系 mapping=&#123; 'get': 'list', 'post': 'create' &#125;, name='&#123;basename&#125;-list', detail=False, initkwargs=&#123;'suffix': 'List'&#125; ), def __init__(self, trailing_slash=True): self.trailing_slash = '/' if trailing_slash else '' super().__init__() def get_default_basename(self, viewset): \"\"\" If `basename` is not specified, attempt to automatically determine it from the viewset. \"\"\" queryset = getattr(viewset, 'queryset', None) assert queryset is not None, '`basename` argument not specified, and could ' \\ 'not automatically determine the name from the viewset, as ' \\ 'it does not have a `.queryset` attribute.' return queryset.model._meta.object_name.lower() def get_routes(self, viewset): # 获取对应关系 known_actions = list(flatten([route.mapping.values() for route in self.routes if isinstance(route, Route)])) # 找出viewsets里所有的方法 extra_actions = viewset.get_extra_actions() # checking action names against the known actions list # 判断路由的方法对应的viewsets的方法 not_allowed = [ action.__name__ for action in extra_actions if action.__name__ in known_actions ] if not_allowed: msg = ('Cannot use the @action decorator on the following ' 'methods, as they are existing routes: %s') raise ImproperlyConfigured(msg % ', '.join(not_allowed)) # partition detail and list actions detail_actions = [action for action in extra_actions if action.detail] list_actions = [action for action in extra_actions if not action.detail] routes = [] for route in self.routes: if isinstance(route, DynamicRoute) and route.detail: routes += [self._get_dynamic_route(route, action) for action in detail_actions] elif isinstance(route, DynamicRoute) and not route.detail: routes += [self._get_dynamic_route(route, action) for action in list_actions] else: routes.append(route) return routes def get_urls(self): \"\"\" Use the registered viewsets to generate a list of URL patterns. \"\"\" ret = [] # 这里的self.registry是父类BaseRouter的一个属性 for prefix, viewset, basename in self.registry: lookup = self.get_lookup_regex(viewset) routes = self.get_routes(viewset) # 这里是对路径进行了不同形式的封装 for route in routes: # Only actions which actually exist on the viewset will be bound mapping = self.get_method_map(viewset, route.mapping) if not mapping: continue # Build the url pattern regex = route.url.format( prefix=prefix, lookup=lookup, trailing_slash=self.trailing_slash ) if not prefix and regex[:2] == '^/': regex = '^' + regex[2:] initkwargs = route.initkwargs.copy() initkwargs.update(&#123; 'basename': basename, 'detail': route.detail, &#125;) view = viewset.as_view(mapping, **initkwargs) name = route.name.format(basename=basename) ret.append(url(regex, view, name=name)) return ret 进入BaseRouter中,截取源码如下: 1234567891011121314151617181920212223242526272829303132333435class BaseRouter: def __init__(self): # SimpleRouter的get_urls中的需要的属性 self.registry = [] def register(self, prefix, viewset, basename=None): # 如果没有basename,则self.get_default_basename()方法 # get_default_basename()方法就是报错要求basename必须有, # 从而看得出来要想使用router组件必须执行register()方法 if basename is None: basename = self.get_default_basename(viewset) self.registry.append((prefix, viewset, basename)) # invalidate the urls cache if hasattr(self, '_urls'): del self._urls def get_default_basename(self, viewset): \"\"\" If `basename` is not specified, attempt to automatically determine it from the viewset. \"\"\" raise NotImplementedError('get_default_basename must be overridden') def get_urls(self): \"\"\" Return a list of URL patterns, given the registered viewsets. \"\"\" raise NotImplementedError('get_urls must be overridden') @property def urls(self): if not hasattr(self, '_urls'): self._urls = self.get_urls() return self._urls DefaultRoute类进行了更好的优化 123456789101112131415161718192021222324252627282930313233343536373839404142class DefaultRouter(SimpleRouter): \"\"\" The default router extends the SimpleRouter, but also adds in a default API root view, and adds format suffix patterns to the URLs. \"\"\" include_root_view = True include_format_suffixes = True root_view_name = 'api-root' default_schema_renderers = None APIRootView = APIRootView APISchemaView = SchemaView SchemaGenerator = SchemaGenerator def __init__(self, *args, **kwargs): if 'root_renderers' in kwargs: self.root_renderers = kwargs.pop('root_renderers') else: self.root_renderers = list(api_settings.DEFAULT_RENDERER_CLASSES) super().__init__(*args, **kwargs) def get_api_root_view(self, api_urls=None): \"\"\" Return a basic root view. \"\"\" api_root_dict = OrderedDict() list_name = self.routes[0].name for prefix, viewset, basename in self.registry: api_root_dict[prefix] = list_name.format(basename=basename) return self.APIRootView.as_view(api_root_dict=api_root_dict) def get_urls(self): urls = super().get_urls() if self.include_root_view: view = self.get_api_root_view(api_urls=urls) root_url = url(r'^$', view, name=self.root_view_name) urls.append(root_url) if self.include_format_suffixes: urls = format_suffix_patterns(urls) return urls 最后路由组件创建了怎么样的url?","categories":[{"name":"django-rest-framework","slug":"django-rest-framework","permalink":"https://liangweijiang.github.io/categories/django-rest-framework/"}],"tags":[{"name":"DRF","slug":"DRF","permalink":"https://liangweijiang.github.io/tags/DRF/"}]},{"title":"DRF源码解析2--viewsets.ModelViewSet对视图的封装","slug":"DRF-02","date":"2020-02-19T13:47:47.427Z","updated":"2020-02-19T15:08:42.664Z","comments":true,"path":"2020/02/19/DRF-02/","link":"","permalink":"https://liangweijiang.github.io/2020/02/19/DRF-02/","excerpt":"","text":"viewsetsdrf中 viewsets 对 view 进行了更加深层的封装,在CBV编程中减少代码的冗余,截取viewsets源码如下 12345678class ModelViewSet(mixins.CreateModelMixin, mixins.RetrieveModelMixin, mixins.UpdateModelMixin, mixins.DestroyModelMixin, mixins.ListModelMixin, GenericViewSet):# 可以看到viewsets中的ModelViewSet只是继承了各种类,每一个类对应CBV的每一个方法,如CreateModelMixin则对应post方法 pass 进入GenericViewSet的源码中,不难发现,GenericViewSet这个类主要是获取我们的数据和处理数据的组件 123class GenericViewSet(ViewSetMixin, generics.GenericAPIView): # GenericViewSet同样是继承了两个类 pass 进入generics.GenericAPIView 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657class GenericAPIView(views.APIView): # queryset就是获取的ORM对象 queryset = None # serializer_class是序列化的类 serializer_class = None lookup_field = 'pk' lookup_url_kwarg = None # The filter backend classes to use for queryset filtering filter_backends = api_settings.DEFAULT_FILTER_BACKENDS # The style to use for queryset pagination. # pagination_class就是和分页组件相关的类,默认为drf配置中的组件 pagination_class = api_settings.DEFAULT_PAGINATION_CLASS def get_queryset(self): # 这里断言就是为了说明在继承这个类时,一定要有queryset属性或覆盖这个方法 assert self.queryset is not None, ( \"'%s' should either include a `queryset` attribute, \" \"or override the `get_queryset()` method.\" % self.__class__.__name__ ) # 获取ORM对象 queryset = self.queryset if isinstance(queryset, QuerySet): # Ensure queryset is re-evaluated on each request. queryset = queryset.all() return queryset def get_serializer(self, *args, **kwargs): serializer_class = self.get_serializer_class() kwargs['context'] = self.get_serializer_context() # serializer_class接收的参数可能不同 return serializer_class(*args, **kwargs) def get_serializer_class(self): # 继承这个类时,一定要有serializer_classt属性或覆盖这个方法 assert self.serializer_class is not None, ( \"'%s' should either include a `serializer_class` attribute, \" \"or override the `get_serializer_class()` method.\" % self.__class__.__name__ ) return self.serializer_class def get_serializer_context(self): return &#123; 'request': self.request, 'format': self.format_kwarg, 'view': self &#125; def filter_queryset(self, queryset): for backend in list(self.filter_backends): queryset = backend().filter_queryset(self.request, queryset, self) return queryset 接着回到ModelViewSet中,进入到mixins.CreateModelMixin的源码中 1234567891011121314151617181920class CreateModelMixin: \"\"\" Create a model instance. \"\"\" def create(self, request, *args, **kwargs): # 这里调用的就是GenericAPIView中的get_serializer serializer = self.get_serializer(data=request.data) serializer.is_valid(raise_exception=True) self.perform_create(serializer) headers = self.get_success_headers(serializer.data) return Response(serializer.data, status=status.HTTP_201_CREATED, headers=headers) def perform_create(self, serializer): serializer.save() def get_success_headers(self, data): try: return &#123;'Location': str(data[api_settings.URL_FIELD_NAME])&#125; except (TypeError, KeyError): return &#123;&#125; 现在我们只需要继承ModelViewSet,然后重写queryset和处理数据所需要的组件类如序列化的类等,但是怎么将self.post对应上self.list方法呢,GenericViewSet还继承了ViewSetMixin,看一下ViewSetMixin的源码的截取 1234567891011121314151617181920212223242526272829303132333435class ViewSetMixin: @classonlymethod # 对as_view()方法又一次封装,action表示可以接收参数了 def as_view(cls, actions=None, **initkwargs): if not actions: raise TypeError(\"The `actions` argument must be provided when \" \"calling `.as_view()` on a ViewSet. For example \" \"`.as_view(&#123;'get': 'list'&#125;)`\") def view(request, *args, **kwargs): self = cls(**initkwargs) # We also store the mapping of request methods to actions, # so that we can later set the action attribute. # eg. `self.action = 'list'` on an incoming GET request. self.action_map = actions # Bind methods to actions # This is the bit that's different to a standard view # method, action退出action为一个字典,&#123;'get':'list'&#125; for method, action in actions.items(): # handler为实例中的各个方法 handler = getattr(self, action) # 这里setattr相当于metmod == handler setattr(self, method, handler) if hasattr(self, 'get') and not hasattr(self, 'head'): self.head = self.get self.request = request self.args = args self.kwargs = kwargs # And continue as usual return self.dispatch(request, *args, **kwargs) return csrf_exempt(view) 奉献一张图来看下我们的继承顺序","categories":[{"name":"django-rest-framework","slug":"django-rest-framework","permalink":"https://liangweijiang.github.io/categories/django-rest-framework/"}],"tags":[{"name":"DRF","slug":"DRF","permalink":"https://liangweijiang.github.io/tags/DRF/"}]},{"title":"DRF源码解析1--APIView对request的重新封装","slug":"DRF-01","date":"2020-02-19T08:58:37.586Z","updated":"2020-02-19T10:08:43.094Z","comments":true,"path":"2020/02/19/DRF-01/","link":"","permalink":"https://liangweijiang.github.io/2020/02/19/DRF-01/","excerpt":"","text":"截取APIView12345678910111213141516171819202122232425262728293031323334353637383940414243444546@classmethodclass APIView(View): def as_view(cls, **initkwargs): if isinstance(getattr(cls, 'queryset', None), models.query.QuerySet): def force_evaluation(): raise RuntimeError( 'Do not evaluate the `.queryset` attribute directly, ' 'as the result will be cached and reused between requests. ' 'Use `.all()` or call `.get_queryset()` instead.' ) cls.queryset._fetch_all = force_evaluation # 继承了django中View类的的as_view()方法,然后重写了dispatch方法 view = super().as_view(**initkwargs) view.cls = cls view.initkwargs = initkwargs return csrf_exempt(view) def dispatch(self, request, *args, **kwargs): self.args = args self.kwargs = kwargs # 在传入request是,apiview对request进行了一次包装 request = self.initialize_request(request, *args, **kwargs) # 此时self.request是initialize_request方法返回的Request self.request = request self.headers = self.default_response_headers # deprecate? try: # 相比于View类的dispatch方法,Apiview在这里进行了一次初始化的方法 self.initial(request, *args, **kwargs) # Get the appropriate handler method if request.method.lower() in self.http_method_names: handler = getattr(self, request.method.lower(), self.http_method_not_allowed) else: handler = self.http_method_not_allowed response = handler(request, *args, **kwargs) except Exception as exc: response = self.handle_exception(exc) self.response = self.finalize_response(request, response, *args, **kwargs) return self.response 进入self.initalize_request()12345678910def initialize_request(self, request, *args, **kwargs): parser_context = self.get_parser_context(request) # 可以看到, request已经被封装成Request返回,而request则被封装成Request的一个属性 return Request( request, parsers=self.get_parsers(), authenticators=self.get_authenticators(), negotiator=self.get_content_negotiator(), parser_context=parser_context ) 截取Ruquest123456789101112131415161718192021222324252627282930class Request: def __init__(self, request, parsers=None, authenticators=None, negotiator=None, parser_context=None): assert isinstance(request, HttpRequest), ( 'The `request` argument must be an instance of ' '`django.http.HttpRequest`, not `&#123;&#125;.&#123;&#125;`.' .format(request.__class__.__module__, request.__class__.__name__) ) # request被封装了私有属性 self._request = request @property def content_type(self): meta = self._request.META # 封装了content_type方法获取传输类型 return meta.get('CONTENT_TYPE', meta.get('HTTP_CONTENT_TYPE', '')) @property def query_params(self): \"\"\" More semantically correct name for request.GET. \"\"\" # django的view中的request.Get属性封装成了query_params属性 return self._request.GET @property def data(self): if not _hasattr(self, '_full_data'): self._load_data_and_files() # django的view中的request.Post属性封装成了data属性 return self._full_data 我们可以看出~CBV在内部做了一个分发,本质和FBV是一样的。 以后做接口开发的时候，就要用CBV，学习了restful规范，现在就很容易理解我们为什么用CBV了。","categories":[{"name":"django-rest-framework","slug":"django-rest-framework","permalink":"https://liangweijiang.github.io/categories/django-rest-framework/"}],"tags":[{"name":"DRF","slug":"DRF","permalink":"https://liangweijiang.github.io/tags/DRF/"}]}]}