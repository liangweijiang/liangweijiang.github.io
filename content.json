{"meta":{"title":"Hexo","subtitle":"","description":"","author":"liangweijiang","url":"https://liangweijiang.github.io","root":"/"},"pages":[{"title":"categories","date":"2020-02-19T09:53:30.000Z","updated":"2020-02-19T09:54:44.015Z","comments":true,"path":"categories/index.html","permalink":"https://liangweijiang.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-02-19T10:00:45.000Z","updated":"2020-02-19T10:01:19.886Z","comments":true,"path":"tags/index.html","permalink":"https://liangweijiang.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"《趣谈网络协议》学习笔记(一)-- 通信协议综述","slug":"NetworkProtocol-01","date":"2020-03-10T08:56:43.896Z","updated":"2020-03-10T08:58:59.656Z","comments":true,"path":"2020/03/10/NetworkProtocol-01/","link":"","permalink":"https://liangweijiang.github.io/2020/03/10/NetworkProtocol-01/","excerpt":"","text":"学习自极客时间《趣谈网络协议》 作者：刘超 通信协议的综述1. 为什么要学习网络协议?1.1 协议的三要素计算机语言作为程序员控制一台计算机工作的协议，具备了协议的三要素。 语法，就是这一段内容要符合一定的规则和格式。例如，括号要成对，结束要使用分号等。 语义，就是这一段内容要代表某种意义。例如数字减去数字是有意义的，数字减去文本一般来说就没有意义。 顺序，就是先干啥，后干啥。例如，可以先加上某个数值，然后再减去某个数值。会了计算机语言，你就能够教给一台计算机完成你的工作了。但是，要想打造互联网世界的通天塔，只教给一台机器做什么是不够的，你需要学会教给一大片机器做什么。这就需要网络协议。只有通过网络协议，才能使一大片机器互相协作、共同完成一件事。 1.2 HTTP协议的格式 HTTP/1.1 200 OKDate: Tue, 27 Mar 2018 16:50:26 GMTContent-Type: text/html;charset=UTF-8Content-Language: zh-CN 首先，符合语法，也就是说，只有按照上面那个格式来，浏览器才认。 例如，上来是状态，然后是首部，然后是内容。第二，符合语义，就是要按照约定的意思来。 例如，状态 200，表述的意思是网页成功返回。如果不成功，就是我们常见的“404”。 第三，符合顺序，你一点浏览器，就是发送出一个 HTTP 请求，然后才有上面那一串 HTTP 返回的东西。浏览器显然按照协议商定好的做了，最后一个五彩缤纷的页面就出现在你面前了 1.3 网络协议的种类 2. 网络分层的真实含义是什么？2.1 网络为什么要分层？ 对于软件世界来说,在计算机领域，任何问题到了某个复杂的阶段，如果当前方法不能解决问题，必定可以通过加多一层来解决，如果加多一层都解决不了问题，那肯定是这个问题模型的层次已经到极限了。 1）各层之间相互独立：高层是不需要知道底层的功能是采取硬件技术来实现的，它只需要知道通过与底层的接口就可以获得所需要的服务；2）灵活性好：各层都可以采用最适当的技术来实现，例如某一层的实现技术发生了变化，用硬件代替了软件，只要这一层的功能与接口保持不变，实现技术的变化都并不会对其他各层以及整个系统的工作产生影响； 3）易于实现和标准化：由于采取了规范的层次结构去组织网络功能与协议，因此可以将计算机网络复杂的通信过程，划分为有序的连续动作与有序的交互过程，有利于将网络复杂的通信工作过程化解为一系列可以控制和实现的功能模块，使得复杂的计算机网络系统变得易于设计，实现和标准化 在网络协议中的分层。不仅仅是根据负责的功能来简单的划分层次，而且层与层之间会有不可缺少的的封装与传递。对于网络模型各层的封装是根据整个网络模型从上到下的工作流程来划分的。但是，每层之间会有一定的联系，不是独立工作的。 2.3 程序是如何工作的？ 2.3 层与层之间联系 只要是在网络上跑的包，都是完整的。可以有下层没上层，绝对不可能有上层没下层。 所以，对 TCP 协议来说，三次握手也好，重试也好，只要想发出去包，就要有 IP 层和 MAC 层，不然是发不出去的。 3. ifconfig：最熟悉又陌生的命令行 linux上查看ip地址的命令有ifconfig和ip addr两种 3.1 ifconfig 和 ip addr 的区别这是一个有关 net-tools 和 iproute2 的“历史”故事，net-tools起源于BSD的TCP/IP工具箱，后来成为老版本Linux内核中配置网络功能的工具，但自2001年起，Linux社区已经对其停止维护。同时，一些Linux发行版比如Arch Linux和CentOS/RHEL 7则已经完全抛弃了net-tools，只支持iproute2。 作为网络配置工具的一份子，iproute2是linux下管理控制TCP/IP网络和流量控制的新一代工具包，旨在替代老派的工具链net-tools，即大家比较熟悉的ifconfig，arp，route，netstat等命令。 net-tools通过procfs(/proc)和ioctl系统调用去访问和改变内核网络配置，而iproute2则通过netlink套接字接口与内核通讯。 抛开性能而言，net-tools的用法给人的感觉是比较乱，而iproute2的用户接口相对net-tools来说相对来说，更加直观。比如，各种网络资源（如link、IP地址、路由和隧道等）均使用合适的对象抽象去定义，使得用户可使用一致的语法去管理不同的对象，更重要的是，到目前为止，iproute2仍处在持续开发中，所以，net-tools和iproute2都需要去学习掌握了。 如果你仍在使用net-tools，而且尤其需要跟上新版Linux内核中的最新最重要的网络特性的话，那么是时候转到iproute2的阵营了。原因就在于使用iproute2可以做很多net-tools无法做到的事情。 3.2 ip地址的分类linux下输入ip addr 12345678910111213root@test:~# ip addr1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000 link/ether fa:16:3e:c7:79:75 brd ff:ff:ff:ff:ff:ff inet 10.100.122.2/24 brd 10.100.122.255 scope global eth0 valid_lft forever preferred_lft forever inet6 fe80::f816:3eff:fec7:7975/64 scope link valid_lft forever preferred_lft forever 在 IP 地址的后面有个 scope，对于 eth0 这张网卡来讲，是 global，说明这张网卡是可以对外的，可以接收来自各个地方的包。对于 lo 来讲，是 host，说明这张网卡仅仅可以供本机相互通信。lo 全称是 loopback，又称环回接口，往往会被分配到 127.0.0.1 这个地址。这个地址用于本机通信，经过内核处理后直接返回，不会在任何网络中出现。 这个命令显示了这台机器上所有的网卡。大部分的网卡都会有一个 IP 地址，当然，这不是必须的。IP 地址是一个网卡在网络世界的通讯地址，相当于我们现实世界的门牌号码 以前人们根本想不到会有这么多的计算机,所以ip地址总共就32位,也就是我们所说的ipv4,可是ipv4很快就别分配完了,于是就出现了ipv6。 iPv4被分成了5类 这里面有个尴尬的事情，就是 C 类地址能包含的最大主机数量实在太少了，只有 254 个。当时设计的时候恐怕没想到，现在估计一个网吧都不够用吧。而 B 类地址能包含的最大主机数量又太多了。6 万多台机器放在一个网络下面，一般的企业基本达不到这个规模，闲着的地址就是浪费。 3.3 无类型域间选路（CIDR） 无类型域间选路(CIDR)基本思想是取消地址的分类结构，取而代之的是允许以可变长分界的方式分配网络数。它支持路由聚合，可限制Internet主干路由器中必要路由信息的增长。“无类型”的意思是选路决策是基于整个32位IP地址的掩码操作。而不管其IP地址是A类、B类或是C类。这样能够将路由表中的许多表项归并(summarization)成更少的数目。 伴随着 CIDR 存在的，一个是广播地址，10.100.122.255。如果发送这个地址，所有 10.100.122 网络里面的机器都可以收到。 另一个是子网掩码，255.255.255.0。将子网掩码和 IP 地址进行 AND 计算。前面三个 255，转成二进制都是 1。1 和任何数值取 AND，都是原来数值，因而前三个数不变，为 10.100.122。后面一个 0，转换成二进制是 0，0 和任何数值取 AND，都是 0，因而最后一个数变为 0，合起来就是 10.100.122.0。这就是网络号。将子网掩码和 IP 地址按位计算 AND，就可得到网络号。 3.4 公有 IP 地址和私有 IP 地址上图中可以看到私有地址的范围,私有地址就是平时我们看到的数据中心里，办公室、家里或学校的 IP 地址，一般都是私有 IP 地址段。因为这些地址允许组织内部的 IT 人员自己管理、自己分配，而且可以重复。因此，你学校的某个私有 IP 地址段和我学校的可以是一样的。就像你的小区有402号房间,我的小区也可以有402号房间,但是一旦出了小区,直接说402房间别人就找不到了。 公有 IP 地址有个组织统一分配，你需要去买。如果你搭建一个网站，给你学校的人使用，让你们学校的 IT 人员给你一个 IP 地址就行。但是假如你要做一个类似网易 163 这样的网站，就需要有公有 IP 地址，这样全世界的人才能访问。 3.5 MAC地址 MAC 地址更像是身份证，是一个唯一的标识。它的唯一性设计是为了组网的时候，不同的网卡放在一个网络里面的时候，可以不用担心冲突。从硬件角度，保证不同的网卡有不同的标识。但是光有mac地址是不够的的，就像光知道你的身份证是很难找得到你的人的，还需要你现在的居住地址（相当于ip地址） MAC地址只有很小范围的定位功能，就像大家在一个房间里，这时候大喊这个人的身份证，就会有对应的人回复你。 mac地址是唯一的，为什么可以修改?想想身份证，身份证号是唯一的，不能改变的，但是可以造价。mac地址全球唯一，它是固化在网卡里的。网卡毕竟是个硬件，需要软件支持，既操作系统识别。重点来了，操作系统识别出来的mac地址是可以更改的，它只不过是一个字符串。我们常说的修改mac指的是修改电脑中记录的既注册表中的记录。 有了mac地址为什么还要有ip地址。举个例子，身份证号是你的唯一标识，不会重复，一落户就有（网卡一出厂就有mac）。现在我要和你通信（写信给你），地址用你的姓名+身份证，信能送到你手上吗?明显不能！身份证号前六位能定位你出生的县。mac地址前几位也可以定位生产厂家。但是你出生后会离开这个县（哪怕在这个县，也不能具体找到你）。所以一般写个人信息就要有出生地和现居地址了 4. DHCP与PXE：IP是怎么来的，又是怎么没的？4.1 配置ip地址使用 net-tools： $ sudo ifconfig eth1 10.0.0.1/24$ sudo ifconfig eth1 up 使用 iproute2： $ sudo ip addr add 10.0.0.1/24 dev eth1$ sudo ip link set up eth1 但是在手动配置ip地址时,不是自由的去配置的,要考虑很多因素,如两台电脑需要通信时,源IP 地址 16.158.23.6，目标 IP 地址 192.168.1.6,因为不是同一个网卡的话,Linux 默认的逻辑是，如果这是一个跨网段的调用，它便不会直接将包发送到网络上，而是企图将包发送到网关。需要经过多次网关才能达到,如果两台电脑是相邻的,如果直接配置成同一个网段的,直接发送ARP请求,节省很多资源. 4.2 动态主机配置协议（DHCP） 概要动态主机配置协议 (DHCP) 是由 RFC 1541（已被 RFC 2131 取代）定义的标准协议，允许服务器将 IP 地址和配置信息动态分发给客户端。正常情况下，DHCP 服务器至少会为客户端提供以下基本信息： IP 地址 子网掩码 默认网关 4.2.1 DHCP 的工作方式: 这里第二步,如果有多个DHCP服务器,新的客户端会收到多个ip地址,一般选择第一个到来的,客户端仍然使用 0.0.0.0 为源 IP 地址、255.255.255.255 为目标地址进行广播。在 BOOTP 里面，接受某个 DHCP Server 的分配的 IP。 4.2.2 IP 地址的收回和续客户机会在租期过去 50% 的时候，直接向为其提供 IP 地址的 DHCP Server 发送 DHCP request 消息包。客户机接收到该服务器回应的 DHCP ACK 消息包，会根据包中所提供的新的租期以及其他已经更新的 TCP/IP 参数，更新自己的配置。这样，IP 租用更新就完成了。 4.3 PXE 的工作过程网络管理员不仅能自动分配 IP 地址，还能帮你自动安装操作系统！我们安装操作系统的过程，只能插在 BIOS 启动之后了。因为没安装系统之前，连启动扇区都没有。因而这个过程叫做预启动执行环境（Pre-boot Execution Environment），简称 PXE。PXE 协议分为客户端和服务器端，由于还没有操作系统，只能先把客户端放在 BIOS 里面。当计算机启动时，BIOS 把 PXE 客户端调入内存里面，就可以连接到服务端做一些操作了。 4.2.4 DCHP总结 DHCP 协议主要是用来给客户租用 IP 地址，和房产中介很像，要商谈、签约、续租，广播还不能“抢单” DHCP 协议能给客户推荐“装修队”PXE，能够安装操作系统，这个在云计算领域大有用处 参考文章动态主机配置协议DHCP 关于ifconfig与ip addr 学习自极客时间 《趣谈网络协议》","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://liangweijiang.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"网络协议","slug":"网络协议","permalink":"https://liangweijiang.github.io/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"}]},{"title":"每日一道算法之--数组中的重复数字","slug":"algorithm-Interview-03","date":"2020-03-09T14:39:07.977Z","updated":"2020-03-09T14:40:55.208Z","comments":true,"path":"2020/03/09/algorithm-Interview-03/","link":"","permalink":"https://liangweijiang.github.io/2020/03/09/algorithm-Interview-03/","excerpt":"","text":"数组中重复的数字力扣面试题03 : https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/ 找出数组中重复的数字。 在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。 示例 1： 输入：[2, 3, 1, 0, 2, 5, 3]输出：2 或 3 限制： 2 &lt;= n &lt;= 100000 这是剑指offer里面的原题,也是比较简单的一道题,但是,一开始我能想到的就是通过排序然后遍历就能够找到重复的数字,时间复杂度为O(logn),或者通过哈希表建立索引,从而使时间复杂度变为O(n),但是要牺牲额外的空间.然后作者给我们提供了一种很好的方法,我暂且叫做下标定位法.看看是怎么实现的吧 1. 排序实现直接看代码: 123456789class Solution: def findRepeatNumber(self, nums: List[int]) -&gt; int: if not nums: return -1 if len(nums) == 1: return nums.sort() for i in range(1, len(nums)): if nums[i] == nums[i - 1]: return nums[i] return -1 2. 利用哈希表实现12345678910class Solution: def findRepeatNumber(self, nums: List[int]) -&gt; int: if not nums: return -1 if len(nums) == 1: return -1 has_map = &#123;&#125; for num in nums: if num in has_map: return num has_map[num] = 1 return -1 3. 下标定位实现 阅读题目可以发现,所有数字都在 0～n-1 的范围内(哈哈我感觉其实救赎出题人有意而为), 这就可以假设如果数组中没有重复的数字, 那么排好序之后,数组每一个下标对应的数,其实就是刚好等于下标的,看到这句话,卧槽,牛逼牛逼!!如果有重复的数,则有些下标可能存在多个数,有的下标可能没有数。 现在可以重新对这个数组排序,从下标为i开始,这个数字为m,如果m不为i,则将a[i]与a[m]比较,如果不相等,则交换;如果相等,则证明找到了重复的数字。这样,下标为m的数它的值也为m了,相当于每个数最多两次交换就能找到它对应的下标. 12345678class Solution: def findRepeatNumber(self, nums: List[int]) -&gt; int: for i in range(len(nums)): while nums[i] != i: if nums[i] == nums[nums[i]]: return nums[i] nums[nums[i]], nums[i] = nums[i], nums[nums[i]] return -1 3.1 复杂度分析时间复杂度:虽然代码中有两层循环,但是每个数最多两次交换就能找到它对应的下标,所以时间复杂度还是为O(n) 空间复杂度:没有用到额外的数据结构,所以空间复杂度为O(1)","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://liangweijiang.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://liangweijiang.github.io/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"负载均衡笔记","slug":"LoadBalancing","date":"2020-03-09T07:16:29.244Z","updated":"2020-03-10T08:58:58.704Z","comments":true,"path":"2020/03/09/LoadBalancing/","link":"","permalink":"https://liangweijiang.github.io/2020/03/09/LoadBalancing/","excerpt":"","text":"负载均衡1 什么是负载均衡?百度百科是这样说的: 负载均衡建立在现有网络结构之上，它提供了一种廉价有效透明的方法扩展网络设备和服务器的带宽、增加吞吐量、加强网络数据处理能力、提高网络的灵活性和可用性。负载均衡（Load Balance）其意思就是分摊到多个操作单元上进行执行，例如Web服务器、FTP服务器、企业关键应用服务器和其它关键任务服务器等，从而共同完成工作任务。 互联网早期，业务流量比较小并且业务逻辑比较简单，单台服务器便可以满足基本的需求；但随着互联网的发展，业务流量越来越大并且业务逻辑也越来越复杂，单台机器的性能问题以及单点问题凸显了出来，因此需要多台机器来进行性能的水平扩展以及避免单点故障。但是要如何将不同的用户的流量分发到不同的服务器上面呢？ 这就是负载均衡所要解决的问题。回到上边请求页面的过程，这个请求此时会被一台专门的服务器来处理，这台服务器其实就是个集群的老大，他负责把这个请求派给下面哪个小弟（服务器）来处理，处理完之后将数据返回给用户。当有多个请求同时发生时，集群的老大可以将请求派给不同的小弟，这样处理的效率就会大幅提升，充分发挥集群的力量，至于哪个请求到底派给哪个小弟，这就是调度策略的问题了。 我的理解就是有一个老大哥给每一小弟安排工作,而且工作不能偏心,要能使每一个小弟都能很好的工作,这样他们的效率就会更高,不会轻易累死小弟… 1.1 负载均衡的特点负载均衡技术具有一下优势： 高性能：负载均衡技术将业务较均衡的分担到多台设备或链路上，从而提高了整个系统的性能； 可扩展性：负载均衡技术可以方便的增加集群中设备或链路的数量，在不降低业务质量的前提下满足不断增长的业务需求； 高可靠性：单个甚至多个设备或链路法神故障也不会导致业务中断，提高了整个系统的可靠性； 可管理性：大量的管理共组都集中在使用负载均衡技术的设备上，设备集群或链路集群只需要维护通过的配置即可； 透明性：对用户而言，集群等于一个或多个高可靠性、高性能的设备或链路，用户感知不到，也不关心具体的网络结构，增加或减少设备或链路数量都不会影响正常的业务。 1.2 负载均衡的分类负载均衡技术分类： 服务器负载均衡：在数据中心等组网环境中，可以采用服务器负载均衡，将网络服务分担给多台服务器进行处理，提高数据中心的业务处理能力； 链路负载均衡：在有多个运营商出接口的组网环境中，可以采用出方向多链路动态负载均衡，实现链路的动态选择，提高服务的可靠性； 防火墙负载均衡：在防火墙处理能力成为瓶颈的组网环境中，可以采用防火墙负载均衡，将网络流量分担给多台防火墙设备，提高防火桥的处理能力； 2. 负载均衡的算法 随机算法Random随机，按权重设置随机概率。在一个截面上碰撞的概率高，但调用量越大分布越均匀，而且按概率使用权重后也比较均匀，有利于动态调整提供者权重。 轮询及加权轮询轮询(Round Robbin)当服务器群中各服务器的处理能力相同时，且每笔业务处理量差异不大时，最适合使用这种算法。 轮循，按公约后的权重设置轮循比率。存在慢的提供者累积请求问题，比如：第二台机器很慢，但没挂，当请求调到第二台时就卡在那，久而久之，所有请求都卡在调到第二台上。加权轮询(Weighted Round Robbin)为轮询中的每台服务器附加一定权重的算法。比如服务器1权重1，服务器2权重2，服务器3权重3，则顺序为1-2-2-3-3-3-1-2-2-3-3-3- …… 最小连接及加权最小连接最少连接(Least Connections)在多个服务器中，与处理连接数(会话数)最少的服务器进行通信的算法。即使在每台服务器处理能力各不相同，每笔业务处理量也不相同的情况下，也能够在一定程度上降低服务器的负载。加权最少连接(Weighted Least Connection)为最少连接算法中的每台服务器附加权重的算法，该算法事先为每台服务器分配处理连接的数量，并将客户端请求转至连接数最少的服务器上。 哈希算法普通哈希一致性哈希一致性Hash，相同参数的请求总是发到同一提供者。当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动。 IP地址散列通过管理发送方IP和目的地IP地址的散列，将来自同一发送方的分组(或发送至同一目的地的分组)统一转发到相同服务器的算法。当客户端有一系列业务需要处理而必须和一个服务器反复通信时，该算法能够以流(会话)为单位，保证来自相同客户端的通信能够一直在同一服务器中进行处理。 URL散列通过管理客户端请求URL信息的散列，将发送至相同URL的请求转发至同一服务器的算法。 3. 负载均衡的实现3.1 HTTP重定向实现负载均衡 HTTP重定向服务器就是一个普通的服务器，当用户访问时，其会根据一定的算法得到服务器集群的一个真实服务器的IP地址，将其放在HTTP响应头中，响应状态码为（302），当用户浏览器接收到这个响应时，会将得到的真实服务器的IP地址提出并重新访问。当浏览器收到响应消息后，解析Location字段，并向该URL发起请求，然后指定的服务器处理该用户的请求，最后将结果返回给用户。 在使用HTTP重定向来实现服务器集群负载均衡的过程中，需要一台服务器作为请求调度者。用户的一项操作需要发起两次HTTP请求，一次向调度服务器发送请求，获取后端服务器的IP，第二次向后端服务器发送请求，获取处理结果。 优点：采用HTTP重定向来实现服务器集群的负载均衡实现起来较为容易，逻辑比较简单。缺点: 这种方式需要用户浏览器访问两次，性能较差 HTTP重定向服务器会的处理能力会成为负载均衡的瓶颈由于不同用户的访问时间 HTTP重定向返回302，可能会使搜索引擎判定为SEO作弊，降低搜索排名,若分配给该用户的后端服务器出现故障，并且如果页面被浏览器缓存，那么当用户再次访问网站时，请求都会发给出现故障的服务器，从而导致访问失败 3.2 DNS负载均衡 当用户向我们的域名发起请求时，DNS服务器会自动地根据我们事先设定好的调度策略选一个合适的IP返回给用户，用户再向该IP发起请求 优点： 将负载均衡工作交给DNS，省略掉了网络管理的麻烦 DNS负载均衡最大的优点就是配置简单。服务器集群的调度工作完全由DNS服务器承担，那么我们就可以把精力放在后端服务器上，保证他们的稳定性与吞吐量。而且完全不用担心DNS服务器的性能，即便是使用了轮询策略，它的吞吐率依然卓越。 DNS负载均衡具有较强了扩展性，你完全可以为一个域名解析较多的IP，而且不用担心性能问题。 缺点： 由于把集群调度权交给了DNS服务器，从而我们没办法随心所欲地控制调度者，没办法定制调度策略。。 当我们发现某一台后端服务器发生故障时，即使我们立即将该服务器从域名解析中去除，但由于DNS服务器会有缓存，该IP仍然会在DNS中保留一段时间，那么就会导致一部分用户无法正常访问网站（可以用动态 DNS来解决）。事实上，大型网站总是部分使用DNS域名解析，作为第一级负载均衡手段，然后再在内部做第二级负载均衡。 3.3 数据链路层负载均衡(LVS)数据链路层负载均衡是指在通信协议的数据链路层修改mac地址进行负载均衡。 这种数据传输方式又称作三角传输模式，负载均衡数据分发过程中不修改IP地址，只修改目的的mac地址，通过配置真实物理服务器集群所有机器虚拟IP和负载均衡服务器IP地址一样，从而达到负载均衡，这种负载均衡方式又称为直接路由方式（DR）. 用户请求到达负载均衡服务器后，负载均衡服务器将请求数据的目的mac地址修改为真是WEB服务器的mac地址，并不修改数据包目标IP地址，因此数据可以正常到达目标WEB服务器，该服务器在处理完数据后可以经过网管服务器而不是负载均衡服务器直接到达用户浏览器。 使用三角传输模式的链路层负载均衡是目前大型网站所使用的最广的一种负载均衡手段。在linux平台上最好的链路层负载均衡开源产品是LVS(linux virtual server)。 3.4 IP层负载均衡先看一下ip层ip包的结构 可以看到结构中有原地址和目标地址这两个部分,这是实现ip层负载均衡的关键,我们就是通过修改这两个地址来达到“转发”目的 用户请求数据包到达负载均衡服务器后，负载均衡服务器在操作系统内核进行获取网络数据包，根据负载均衡算法计算得到一台真实的WEB服务器地址，然后将数据包的IP地址修改为真实的WEB服务器地址，不需要通过用户进程处理。真实的WEB服务器处理完毕后，相应数据包回到负载均衡服务器，负载均衡服务器再将数据包源地址修改为自身的IP地址发送给用户浏览器。 这里的关键在于真实WEB服务器相应数据包如何返回给负载均衡服务器，一种是负载均衡服务器在修改目的IP地址的同时修改源地址，将数据包源地址改为自身的IP，即源地址转换（SNAT），另一种方案是将负载均衡服务器同时作为真实物理服务器的网关服务器，这样所有的数据都会到达负载均衡服务器。 优点: IP负载均衡在内核进程完成数据分发，较反向代理均衡有更好的处理性能。缺点: 由于所有请求响应的数据包都需要经过负载均衡服务器，因此负载均衡的网卡带宽成为系统的瓶颈。 3.5 反向代理负载均衡(nginx) 代理与反向代理:VPN服务就是我们常用的一种代理（正向代理），用户将请教交给代理服务器，代理服务器访问网站获取数据，之后代理服务器再将数据返还给用户。在这个过程中，应用服务器并不知道用户的存在。只知道代理浏览器的访问。反向代理是指在服务器端的代理，代理服务器接收用户的请求，再转发给真实服务器，之后再返回给代理服务器再给用户，在这个过程中，用户并不知道真实服务器的存在。 传统代理服务器位于浏览器一端，代理浏览器将HTTP请求发送到互联网上。而反向代理服务器则位于网站机房一侧，代理网站web服务器接收http请求。 反向代理的作用是保护网站安全，所有互联网的请求都必须经过代理服务器，相当于在web服务器和可能的网络攻击之间建立了一个屏障。 除此之外，代理服务器也可以配置缓存加速web请求。当用户第一次访问静态内容的时候，静态内存就被缓存在反向代理服务器上，这样当其他用户访问该静态内容时，就可以直接从反向代理服务器返回，加速web请求响应速度，减轻web服务器负载压力。 另外，反向代理服务器也可以实现负载均衡的功能。 反向代理服务器管理了一组服务器，当用户访问时，代理服务器根据负载均衡算法将请求转发到真实服务器，真实服务器也通过反向代理服务器返还数据。内部服务器不对外部提供服务，所以不需要外部IP，而反向代理服务器需要两个网卡，一个IP用于外部用户访问使用，另外一个用于内部使用 优点： 隐藏后端服务器。与HTTP重定向相比，反向代理能够隐藏后端服务器，所有浏览器都不会与后端服务器直接交互，从而能够确保调度者的控制权，提升集群的整体性能。 故障转移。与DNS负载均衡相比，反向代理能够更快速地移除故障结点。当监控程序发现某一后端服务器出现故障时，能够及时通知反向代理服务器，并立即将其删除。 合理分配任务 。HTTP重定向和DNS负载均衡都无法实现真正意义上的负载均衡，也就是调度服务器无法根据后端服务器的实际负载情况分配任务。但反向代理服务器支持手动设定每台后端服务器的权重。我们可以根据服务器的配置设置不同的权重，权重的不同会导致被调度者选中的概率的不同。 缺点： 调度者压力过大 。由于所有的请求都先由反向代理服务器处理，那么当请求量超过调度服务器的最大负载时，调度服务器的吞吐率降低会直接降低集群的整体性能。 制约扩展。当后端服务器也无法满足巨大的吞吐量时，就需要增加后端服务器的数量，可没办法无限量地增加，因为会受到调度服务器的最大吞吐量的制约。 4. 四层和七层负载均衡的区别 源自:负载均衡基础知识:https://www.cnblogs.com/danbing/p/7459224.html作者: 金钟路上小码工 4.1 技术原理上的区别。 所谓四层负载均衡，也就是主要通过报文中的目标地址和端口，再加上负载均衡设备设置的服务器选择方式，决定最终选择的内部服务器。 以常见的TCP为例，负载均衡设备在接收到第一个来自客户端的SYN 请求时，即通过上述方式选择一个最佳的服务器，并对报文中目标IP地址进行修改(改为后端服务器IP），直接转发给该服务器。TCP的连接建立，即三次握手是客户端和服务器直接建立的，负载均衡设备只是起到一个类似路由器的转发动作。在某些部署情况下，为保证服务器回包可以正确返回给负载均衡设备，在转发报文的同时可能还会对报文原来的源地址进行修改。 所谓七层负载均衡，也称为“内容交换”，也就是主要通过报文中的真正有意义的应用层内容，再加上负载均衡设备设置的服务器选择方式，决定最终选择的内部服务器。 以常见的TCP为例，负载均衡设备如果要根据真正的应用层内容再选择服务器，只能先代理最终的服务器和客户端建立连接(三次握手)后，才可能接受到客户端发送的真正应用层内容的报文，然后再根据该报文中的特定字段，再加上负载均衡设备设置的服务器选择方式，决定最终选择的内部服务器。 负载均衡设备在这种情况下，更类似于一个代理服务器。负载均衡和前端的客户端以及后端的服务器会分别建立TCP连接。所以从这个技术原理上来看，七层负载均衡明显的对负载均衡设备的要求更高，处理七层的能力也必然会低于四层模式的部署方式。 4.2 应用场景的需求。 七层应用负载的好处，是使得整个网络更”智能化”, 参考我们之前的另外一篇专门针对HTTP应用的优化的介绍，就可以基本上了解这种方式的优势所在。例如访问一个网站的用户流量，可以通过七层的方式，将对图片类的请求转发到特定的图片服务器并可以使用缓存技术；将对文字类的请求可以转发到特定的文字服务器并可以使用压缩技术。 当然这只是七层应用的一个小案例，从技术原理上，这种方式可以对客户端的请求和服务器的响应进行任意意义上的修改，极大的提升了应用系统在网络层的灵活性。很多在后台，(例如Nginx或者Apache)上部署的功能可以前移到负载均衡设备上，例如客户请求中的Header重写，服务器响应中的关键字过滤或者内容插入等功能。 另外一个常常被提到功能就是安全性。网络中最常见的SYN Flood攻击，即黑客控制众多源客户端，使用虚假IP地址对同一目标发送SYN攻击，通常这种攻击会大量发送SYN报文，耗尽服务器上的相关资源，以达到Denial of Service(DoS)的目的。 从技术原理上也可以看出，四层模式下这些SYN攻击都会被转发到后端的服务器上；而七层模式下这些SYN攻击自然在负载均衡设备上就截止，不会影响后台服务器的正常运营。另外负载均衡设备可以在七层层面设定多种策略，过滤特定报文，例如SQL Injection等应用层面的特定攻击手段，从应用层面进一步提高系统整体安全。 现在的7层负载均衡，主要还是着重于应用广泛的HTTP协议，所以其应用范围主要是众多的网站或者内部信息平台等基于B/S开发的系统。 4层负载均衡则对应其他TCP应用，例如基于C/S开发的ERP等系统。 参考文章几种常见的负载均衡 负载均衡基础知识 关于负载均衡的详细介绍（通俗易懂） 负载均衡","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://liangweijiang.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"负载均衡","slug":"负载均衡","permalink":"https://liangweijiang.github.io/tags/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"},{"name":"云计算","slug":"云计算","permalink":"https://liangweijiang.github.io/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"}]},{"title":"每日一道算法之--组合总和","slug":"algorithm-39","date":"2020-03-05T12:55:27.140Z","updated":"2020-03-05T12:56:39.571Z","comments":true,"path":"2020/03/05/algorithm-39/","link":"","permalink":"https://liangweijiang.github.io/2020/03/05/algorithm-39/","excerpt":"","text":"组合总和力扣第39题:https://leetcode-cn.com/problems/combination-sum/参考文章回溯算法 + 剪枝 极客时间-数据结构与算法之美 给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。 candidates 中的数字可以无限制重复被选取。 说明： 所有数字（包括 target）都是正整数。 解集不能包含重复的组合。示例 1: 输入: candidates = [2,3,6,7], target = 7,所求解集为:[[7],[2,2,3]] 示例 2: 输入: candidates = [2,3,5], target = 8,所求解集为:[ [2,2,2,2], [2,3,3], [3,5]] 回溯思想当我第一眼看到这个题的时候,我第一时间想到就是DP,但是仔细阅读题目的时候就可以发现,这道题是求所有可能的总和,而动态规划只能解决最有问题,所以以后遇到求总和问题的时候,就应该先想到回溯的思想去解决问题. 回溯的处理思想，有点类似枚举搜索。我们枚举所有的解，找到满足期望的解。为了有规律地枚举所有可能的解，避免遗漏和重复，我们把问题求解的过程分为多个阶段。每个阶段，我们都会面对一个岔路口，我们先随意选一条路走，当发现这条路走不通的时候（不符合期望的解），就回退到上一个岔路口，另选一种走法继续走。 相信看过明日边缘和蝴蝶效应这些电影的人应该很容易去理解回溯,下面就来用回溯思想去分析一下这道题. 可以看到,以蓝色点递归可以找到所有的组合 但是有一些节点是重复的,因为递归时没有加限制条件,更深一层的递归又会重复去考虑之前已经计算过的组合,所以需要去排序. 排好序之后,当候选数组的元素比目标数还大时,该元素后面的数可以都不用去考虑了. 123456789101112131415161718class Solution: def combinationSum(self, candidates: List[int], target: int) -&gt; List[List[int]]: candidates.sort() n = len(candidates) res = [] def helper(start, cur_num, tmp): if cur_num == 0: res.append(tmp) return # 这里是去重, 排序之后,start前面的元素都不用去考虑了 for i in range(start, n): # 剪枝,该元素比目标数还大,则直接跳出 # 这里是自下往上组合,上图中是自上往下组合,原理都一样 if cur_num - candidates[i] &lt; 0: break helper(i, cur_num - candidates[i], tmp + [candidates[i]]) helper(0, target, []) return res 复杂度分析时间复杂度:每一次递归遍历考虑所有可能的组合,所以时间复杂度为$$O(n^2)$$ 空间复杂度:O(n) 总结回溯思想可能是一个时间复杂度较高的算法,很多时候可以用dp去优化,但是在枚举所有可能的结果的时候,就是发挥它的特点的时候了,不要因为复杂度高就不去考虑,所以还是的脚踏实地去学习编程吧!!! 相似题目 组合总和II 组合总和III 全排列 N皇后","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://liangweijiang.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://liangweijiang.github.io/tags/%E6%95%B0%E7%BB%84/"},{"name":"回溯思想","slug":"回溯思想","permalink":"https://liangweijiang.github.io/tags/%E5%9B%9E%E6%BA%AF%E6%80%9D%E6%83%B3/"}]},{"title":"python单例模式的实现","slug":"python-02","date":"2020-03-04T08:13:02.751Z","updated":"2020-03-04T08:18:12.492Z","comments":true,"path":"2020/03/04/python-02/","link":"","permalink":"https://liangweijiang.github.io/2020/03/04/python-02/","excerpt":"","text":"单例模式什么是单例模式 单例模式（Singleton Pattern）是一种常用的软件设计模式，该模式的主要目的是确保某一个类只有一个实例存在。当你希望在整个系统中，某个类只能出现一个实例时，单例对象就能派上用场。 比如，某个服务器程序的配置信息存放在一个文件中，客户端通过一个 AppConfig 的类来读取配置文件的信息。如果在程序运行期间，有很多地方都需要使用配置文件的内容，也就是说，很多地方都需要创建 AppConfig 对象的实例，这就导致系统中存在多个 AppConfig 的实例对象，而这样会严重浪费内存资源，尤其是在配置文件内容很多的情况下。事实上，类似 AppConfig 这样的类，我们希望在程序运行期间只存在一个实例对象。 单例模式的实现python实现单例模式有多种实现方法，下面一一来解释说明 1. 基于装饰器的单例模式的实现12345678910111213141516171819202122232425def singleton(cls): # 创建一个字典用来保存类的实例对象 _instance = &#123;&#125; def _singleton(*args, **kwargs): # 先判断这个类有没有对象 if cls not in _instance: _instance[cls] = cls(*args, **kwargs) # 创建一个对象,并保存到字典当中 # 将实例对象返回 return _instance[cls] return _singleton@singletonclass A(object): a = 1 def __init__(self, x=0): self.x = x print('这是A的类的初始化方法')a1 = A(2)a2 = A(3)print(a1.x, a2.x)print(id(a1), id(a2)) 可以看到打印结果为: 2. 基于类方法的单例模式的实现123456789101112131415161718192021class A: def __init__(self, x, y): self.x = x self.y = y @classmethod def singleton(cls, *args, **kwargs): if not hasattr(cls, '__instance'): cls.__instance = cls(*args, **kwargs) return cls.__instanceobj1 = A(1, 2)obj2 = A(3, 4)print(obj1.x, obj1.y, obj2.x, obj2.y)print(id(obj1), id(obj2))obj3 = A.singleton(1, 2)obj4 = A.singleton(3, 4)print(obj3.x, obj3.y, obj4.x, obj4.y)print(id(obj3), id(obj4) 打印结果如下: 但是这个实现方法在多线程上会出现堵塞现象,所以需要加锁1234567891011121314151617181920212223242526import threadingclass A: _instance_lock = threading.Lock() def __init__(self, x, y): self.x = x self.y = y @classmethod def singleton(cls, *args, **kwargs): if not hasattr(cls, '__instance'): with cls._instance_lock: cls.__instance = cls(*args, **kwargs) return cls.__instanceobj1 = A(1, 2)obj2 = A(3, 4)print(obj1.x, obj1.y, obj2.x, obj2.y)print(id(obj1), id(obj2))obj3 = A.singleton(1, 2)obj4 = A.singleton(3, 4)print(obj3.x, obj3.y, obj4.x, obj4.y)print(id(obj3), id(obj4)) 可以发现,使用类方法创建单例模式时,必须要调用该方法,否则直接调用类得到的并不是单例 3. 基于new方法实现单例模式(推荐) 一个对象的实例化过程是先执行类的new方法,如果我们没有写,默认会调用object的new方法,返回一个实例化对象,然后再调用init方法,对这个对象进行初始化,我们可以根据这个实现单例. 在一个类的new方法中先判断是不是存在实例,如果存在实例,就直接返回,如果不存在实例就创建. 1234567891011121314151617import threadingclass A: _instance_lock = threading.Lock() def __new__(cls, *args, **kwargs): if not hasattr(cls, '__instance'): with cls._instance_lock: if not hasattr(cls, '__instance'): cls.__instance = super().__new__(cls) return cls.__instanceobj1 = A()obj2 = A()print(obj1, obj2)print(id(obj1), id(obj2)) 45.基于metaclass方式实现 类由type创建，创建类时，type的init方法自动执行，类() 执行type的 call方法(类的new方法,类的init方法) 对象由类创建，创建对象时，类的init方法自动执行，对象()执行类的 call 方法 1234567891011class Foo: def __init__(self): pass def __call__(self, *args, **kwargs): passobj = Foo()# 执行type的 __call__ 方法，调用 Foo类（是type的对象）的 __new__方法，用于创建对象，然后调用 Foo类（是type的对象）的 __init__方法，用于对对象初始化。obj() # 执行Foo的 __call__ 方法 元类的使用 1234567891011121314151617181920class SingletonType(type): #只有继承了type类才能称之为一个元类，否则就是一个普通的自定义类 def __init__(self,*args,**kwargs): super(SingletonType,self).__init__(*args,**kwargs) def __call__(cls, *args, **kwargs): # 这里的cls，即Foo类 print('cls',cls) # __new__()创建对象 obj = cls.__new__(cls,*args, **kwargs) # __init__()实例化对象 cls.__init__(obj,*args, **kwargs) # Foo.__init__(obj) return objclass Foo(metaclass=SingletonType): # 指定创建Foo的type为SingletonType def __init__(self，name): self.name = name def __new__(cls, *args, **kwargs): return object.__new__(cls)obj = Foo('xx') 实现单例模式 1234567891011121314151617181920import threadingclass SingletonType(type): _instance_lock = threading.Lock() def __call__(cls, *args, **kwargs): if not hasattr(cls, \"_instance\"): with SingletonType._instance_lock: if not hasattr(cls, \"_instance\"): cls._instance = super(SingletonType,cls).__call__(*args, **kwargs) return cls._instanceclass Foo(metaclass=SingletonType): def __init__(self,name): self.name = nameobj1 = Foo('name')obj2 = Foo('name')print(obj1,obj2)","categories":[{"name":"python","slug":"python","permalink":"https://liangweijiang.github.io/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://liangweijiang.github.io/tags/python/"},{"name":"设计模式","slug":"设计模式","permalink":"https://liangweijiang.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"python与其他语言的对比","slug":"python-01","date":"2020-03-04T05:12:40.670Z","updated":"2020-03-08T15:10:45.420Z","comments":true,"path":"2020/03/04/python-01/","link":"","permalink":"https://liangweijiang.github.io/2020/03/04/python-01/","excerpt":"","text":"python与其他语言的对比1.C语言 它既有高级语言的特点，又具有汇编语言的特点，它是结构式语言。C语言应用指针：可以直接进行靠近硬件的操作，但是C的指针操作不做保护，也给它带来了很多不安全的因素。C++在这方面做了改进，在保留了指针操作的同时又增强了安全性，受到了一些用户的支持，但是，由于这些改进增加语言的复杂度，也为另一部分所诟病。Java则吸取了C++的教训，取消了指针操作，也取消了C++改进中一些备受争议的地方，在安全性和适合性方面均取得良好的效果，但其本身解释在虚拟机中运行，运行效率低于C++/C。一般而言，C，C++，java被视为同一系的语言，它们长期占据着程序使用榜的前三名。 C语言的优点：简洁紧凑、灵活方便；运算符丰富；数据类型丰富；表达方式灵活实用；允许直接访问物理地址，对硬件进行操作；生成目标代码质量高，程序执行效率高；可移植性好；表达力强； C语言的缺点：C语言的缺点主要表现在数据的封装性上，这一点使得C在数据的安全性上有很大缺陷，这也是C和C++的一大区别。 C语言的语法限制不太严格，对变量的类型约束不严格，影响程序的安全性，对数组下标越界不作检查等。从应用的角度，C语言比其他高级语言较难掌握。也就是说，对用C语言的人，要求对程序设计更熟练一些。 2.c++语言 C++是C语言的继承，它既可以进行C语言的过程化程序设计，又可以进行以抽象数据类型为特点的基于对象的程序设计，还可以进行以继承和多态为特点的面向对象的程序设计。C++擅长面向对象程序设计的同时，还可以进行基于过程的程序设计，因而C++就适应的问题规模而论，大小由之。 C++不仅拥有计算机高效运行的实用性特征，同时还致力于提高大规模程序的编程质量与程序设计语言的问题描述能力。 C++语言的程序因为要体现高性能，所以都是编译型的。但其开发环境，为了方便测试，将调试环境做成解释型的。即开发过程中，以解释型的逐条语句执行方式来进行调试，以编译型的脱离开发环境而启动运行的方式来生成程序最终的执行代码。 生成程序是指将源码（C++语句）转换成一个可以运行的应用程序的过程。如果程序的编写是正确的，那么通常只需按一个功能键，即可搞定这个过程。该过程实际上分成两个步骤。 第一步是对程序进行编译，这需要用到编译器（compiler）。编译器将C++语句转换成机器码(也称为目标码)；如果这个步骤成功，下一步就是对程序进行链接，这需要用到链接器（linker）。链接器将编译获得机器码与C++库中的代码进行合并。C++库包含了执行某些常见任务的函数（“函数”是子程序的另一种称呼）。例如，一个C++库中包含标准的平方根函数sqrt，所以不必亲自计算平方根。C++库中还包含一些子程序，它们把数据发送到显示器，并知道如何读写硬盘上的数据文件。 3. C#语言 C#是微软公司发布的一种面向对象的、运行于.NET Framework之上的高级程序设计语言。C#看起来与Java有着惊人的相似；它包括了诸如单一继承、接口、与Java几乎同样的语法和编译成中间代码再运行的过程。但是C#与Java有着明显的不同，它借鉴了Delphi的一个特点，与COM（组件对象模型）是直接集成的，而且它是微软公司 .NET windows网络框架的主角。首先，C# 和JAVA一样，简直就是照搬了C++的部分语法，因此，对于数量众多的C++程序员学习起来很容易上手，另外，对于新手来说，比C++要简单一些。其次，Windows是占垄断地位的平台，而开发Windows应用，当然微软的声音是不能忽略的。最重要的是，相对于C++，用C# 开发应用软件可以大大缩短开发周期，同时可以利用原来除用户界面代码之外的C++代码。 4. Java语言 Java是一种可以撰写跨平台应用软件的面向对象的程序设计语言，是由Sun Microsystems公司于1995年5月推出的Java程序设计语言和Java平台（即JavaSE, JavaEE, JavaME）的总称。Java 技术具有卓越的通用性、高效性、平台移植性和安全性，广泛应用于个人PC、数据中心、游戏控制台、科学超级计算机、移动电话和互联网，同时拥有全球最大的开发者专业社群。在全球云计算和移动互联网的产业环境下，Java更具备了显著优势和广阔前景。 Java的优势，与传统程序不同，Sun 公司在推出 Java 之际就将其作为一种开放的技术。全球数以万计的 Java 开发公司被要求所设计的 Java软件必须相互兼容。“Java 语言靠群体的力量而非公司的力量”是Sun公司的口号之一，并获得了广大软件开发商的认同。这与微软公司所倡导的注重精英和封闭式的模式完全不同。Sun 公司对 Java 编程语言的解释是：Java 编程语言是个简单、面向对象、分布式、解释性、健壮、安全与系统无关、可移植、高性能、多线程和动态的语言。 5.php语言 PHP（PHP: Hypertext Preprocessor的缩写，中文名：“PHP：超文本预处理器”）是一种通用开源脚本语言。语法吸收了C语言、Java和Perl的特点，入门门槛较低，易于学习，使用广泛，主要适用于Web开发领域。 的执行动态网页——动态页面方面，与其他的编程语言相比，PHP是将程序嵌入到HTML文档中去执行，执行效率比完全生成htmL标记的CGI要高许多，PHP具有非常强大的功能，所有的CGI的功能PHP都能实现； PHP支持几乎所有流行的数据库以及操作系统；最重要的是PHP可以用C、C++进行程序的扩展。 6.python语言 python是一种面向对象、直译式计算机程序设计语言，Python语法简洁而清晰，具有丰富和强大的类库。它常被昵称为胶水语言，它能够很轻松的把用其他语言制作的各种模块（尤其是C/C++）轻松地联结在一起。常见的一种应用情形是，使用python快速生成程序的原型（有时甚至是程序的最终界面），然后对其中有特别要求的部分，用更合适的语言改写。 Python是完全面向对象的语言。函数、模块、数字、字符串都是对象。并且完全支持继承、重载、派生、多继承，有益于增强源代码的复用性。Python支持重载运算符和动态类型。相对于Lisp这种传统的函数式编程语言，Python对函数式设计只提供了有限的支持。有两个标准库(functools, itertools)提供了Haskell和Standard ML中久经考验的函数式程序设计工具。Python本身被设计为可扩充的。并非所有的特性和功能都集成到语言核心。Python提供了丰富的API和工具，以便程序员能够轻松地使用C语言、C++、Cython来编写扩充模块。Python编译器本身也可以被集成到其它需要脚本语言的程序内。因此，很多人还把Python作为一种“胶水语言”（glue language）使用。使用Python将其他语言编写的程序进行集成和封装。 编译型语言和解释型语言 编译性语言(需要编译器,相当于翻译) 只须编译一次就可以把源代码编译成机器语言，后面的执行无须重新编译，直接使用之前的编译结果就可 以；因此其执行的效率比较高； 编译性语言代表：C、C++、Pascal/Object Pascal（Delphi）； 程序执行效率比较高，但比较依赖编译器，调试麻烦, 因此跨平台性差一些； 不同平台对编译器影响较大。如：（1）16位系统下int是2个字节（16位），而32位系统下int占4个字节（32位）；（2）32位系统下long类型占4字节，而64位系统下long类型占8个字节； 解释型语言（需要解释器，相当于同声传译） 源代码不能直接翻译成机器语言，而是先翻译成中间代码，再由解释器对中间代码进行解释运行； 程序不需要编译，程序在运行时才翻译成机器语言，每执行一次都要翻译一次； 解释型跨平台好，一份代码，到处使用 解释性语言代表：Python、JavaScript、Shell、Ruby、MATLAB等； 运行效率一般相对比较低，依赖解释器，跨平台性好； python解释器的种类和特点CPythonCPython是使用最广且被的Python解释器。本教程以CPython为准。当我们从Python官方网站下载并安装好Python 2.7后，我们就直接获得了一个官方版本的解释器：CPython。这个解释器是用C语言开发的，所以叫CPython。在命令行下运行python就是启动CPython解释器。 IPythonIPython是基于CPython之上的一个交互式解释器，也就是说，IPython只是在交互方式上有所增强，但是执行Python代码的功能和CPython是完全一样的。好比很多国产浏览器虽然外观不同，但内核其实都是调用了IE。CPython用&gt;&gt;&gt;作为提示符，而IPython用In [序号]:作为提示符。 PyPyPyPy是另一个Python解释器，它的目标是执行速度。PyPy采用JIT技术，对Python代码进行动态编译（注意不是解释），所以可以显著提高Python代码的执行速度。 绝大部分Python代码都可以在PyPy下运行，但是PyPy和CPython有一些是不同的，这就导致相同的Python代码在两种解释器下执行可能会有不同的结果。如果你的代码要放到PyPy下执行，就需要了解PyPy和CPython的不同点。 JythonJython是运行在Java平台上的Python解释器，可以直接把Python代码编译成Java字节码执行。 IronPythonIronPython和Jython类似，只不过IronPython是运行在微软.Net平台上的Python解释器，可以直接把Python代码编译成.Net的字节码。","categories":[{"name":"python","slug":"python","permalink":"https://liangweijiang.github.io/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://liangweijiang.github.io/tags/python/"}]},{"title":"python的垃圾回收机制","slug":"python-GC","date":"2020-03-04T04:07:35.310Z","updated":"2020-03-05T04:11:27.598Z","comments":true,"path":"2020/03/04/python-GC/","link":"","permalink":"https://liangweijiang.github.io/2020/03/04/python-GC/","excerpt":"","text":"python的垃圾回收机制 垃圾回收机制是自动帮助我们管理内存，清理垃圾的一种工具1）、引用计数当一个对象的引用被创建或者复制时，对象的引用计数加1；当一个对象的引用被销毁时，对象的引用计数减1；当对象的引用计数减少为0时，就意味着对象已经没有被任何人使用了，可以将其所占用的内存释放了。2）、标记-清除标记-清除不改动真实的引用计数，而是将集合中对象的引用计数复制一份副本，改动该对象引用的副本。对于副本做任何的改动，都不会影响到对象生命走起的维护。3）、分代回收将系统中的所有内存块根据其存活时间划分为不同的集合，每一个集合就成为一个“代”，垃圾收集的频率随着“代”的存活时间的增大而减小。也就是说，活得越长的对象，就越不可能是垃圾，就应该减少对它的垃圾收集频率。那么如何来衡量这个存活时间：通常是利用几次垃圾收集动作来衡量，如果一个对象经过的垃圾收集次数越多，可以得出：该对象存活时间就越长。 1. 引用计数python一切皆对象,每一个对象都保存了一个称为引用计数的整数值，来追踪到底有多少引用指向了这个对象。无论何时，如果我们程序中的一个变量或其他对象引用了目标对象，Python将会增加这个计数值。 对象被创建 a=14 对象被引用 b=a 对象被作为参数,传到函数中 func(a) 对象作为一个元素，存储在容器中 List={a,”a”,”b”,2} 而当程序停止使用这个对象，则Python会减少这个计数值。一旦计数值被减到零，Python将会释放这个对象以及回收相关内存空间。 当该对象的别名被显式销毁时 del a 当该对象的引别名被赋予新的对象， a=26 一个对象离开它的作用域，例如 func函数执行完毕时，函数里面的局部变量的引用计数器就会减一（但是全局变量不会） 将该元素从容器中删除时，或者容器被销毁时。 当指向该对象的内存的引用计数器为0的时候，该内存将会被Python虚拟机销毁 1.1 引用计数的优点可以看出,引用计数有以下几个优点: 高效 运行期没有停顿 可以类比一下Ruby的垃圾回收机制，也就是 实时性：一旦没有引用，内存就直接释放了。不用像其他机制等到特定时机。实时性还带来一个好处：处理回收内存的时间分摊到了平时。 对象有确定的生命周期 易于实现,简单直观 但是针对引用计数这种算法来说，如果一个数据结构引用了它自身，即如果这个数据结构是一个循环数据结构，那么某些引用计数值是肯定无法变成零的。为了更好地理解这个问题，让我们举个例子。 123456a = &#123; &#125; #对象A的引用计数为 1b = &#123; &#125; #对象B的引用计数为 1a['b'] = b #B的引用计数增1b['a'] = a #A的引用计数增1del a #A的引用减 1，最后A对象的引用为 1del b #B的引用减 1, 最后B对象的引用为 1 在这个例子中程序执行完del语句后，A、B对象已经没有任何引用指向这两个对象，但是这两个对象各包含一个对方对象的引用，虽然最后两个对象都无法通过其它变量来引用这两个对象了，这对GC来说就是两个非活动对象或者说是垃圾对象，但是他们的引用计数并没有减少到零。因此如果是使用引用计数法来管理这两对象的话，他们并不会被回收，它会一直驻留在内存中，就会造成了内存泄漏（内存空间在使用完毕后未释放）。 1.2 引用计数的缺点虽然引用计数有着非常简单高效的优点,但是他也有这致命的缺点 维护引用计数消耗资源，维护引用计数的次数和引用赋值成正比，而不像mark and sweep等基本与回收的内存数量有关。 无法解决循环引用的问题 为了解决对象的循环引用问题，Python引入了标记-清除和分代回收两种GC机制。 2. 标记清除 『标记清除（Mark—Sweep）』算法是一种基于追踪回收（tracing GC）技术实现的垃圾回收算法。它分为两个阶段：第一阶段是标记阶段，GC会把所有的『活动对象』打上标记，第二阶段是把那些没有标记的对象『非活动对象』进行回收。那么GC又是如何判断哪些是活动对象哪些是非活动对象的呢？ 对象之间通过引用（指针）连在一起，构成一个有向图，对象构成这个有向图的节点，而引用关系构成这个有向图的边。从根对象（root object）出发，沿着有向边遍历对象，可达的（reachable）对象标记为活动对象，不可达的对象就是要被清除的非活动对象。根对象就是全局变量、调用栈、寄存器。 标记阶段，遍历所有的GC Roots对象(栈区中的所有内容或者线程都可以作为GC Roots对象），然后将所有 GC Roots的对象可以直接或间接访问到的对象标记为存活的对象，其余的均为非存活对象，应该被清除; 清除阶段，再次遍历对象，如果发现某个对象没有标记为可达，则就将其回收。 在上图中，我们把小黑圈视为全局变量，也就是把它作为root object，从小黑圈出发，对象1可直达，那么它将被标记，对象2、3可间接到达也会被标记，而4和5不可达，那么1、2、3就是活动对象，4和5是非活动对象会被GC回收。 标记清除算法作为Python的辅助垃圾收集技术主要处理的是一些容器对象，比如list、dict、tuple，instance等，因为对于字符串、数值对象是不可能造成循环引用问题。Python使用一个双向链表将这些容器对象组织起来。 不过，这种简单粗暴的标记清除算法也有明显的缺点：清除非活动的对象前它必须顺序扫描整个堆内存，哪怕只剩下小部分活动对象也要扫描所有对象，而且会暂停整个应用程序，等待标记清除结束后才会恢复应用程序的运行 3. 分代回收分代回收是一种以空间换时间的操作方式，Python将内存根据对象的存活时间划分为不同的集合，每个集合称为一个代，Python将内存分为了3“代”，分别为年轻代（第0代）、中年代（第1代）、老年代（第2代），他们对应的是3个链表，它们的垃圾收集频率与对象的存活时间的增大而减小。新创建的对象都会分配在年轻代，年轻代链表的总数达到上限时，Python垃圾收集机制就会被触发，把那些可以被回收的对象回收掉，而那些不会回收的对象就会被移到中年代去，依此类推，老年代中的对象是存活时间最久的对象，甚至是存活于整个系统的生命周期内。同时，分代回收是建立在标记清除技术基础之上。分代回收同样作为Python的辅助垃圾收集技术处理那些容器对象。 新定义的变量，放到新生代这个等级中，假设每隔1分钟扫描新生代一次，如果发现变量依然被引用，那么该对象的权重（权重本质就是个整数）加一，当变量的权重大于某个设定得值（假设为3），会将它移动到更高一级的青春代，青春代的gc扫描的频率低于新生代（扫描时间间隔更长），假设5分钟扫描青春代一次，这样每次gc需要扫描的变量的总个数就变少了，节省了扫描的总时间，接下来，青春代中的对象，也会以同样的方式被移动到老年代中。也就是等级（代）越高，被垃圾回收机制扫描的频率越低 分代回收是基于这样的一个统计事实，对于程序，存在一定比例的内存块的生存周期比较短；而剩下的内存块，生存周期会比较长，甚至会从程序开始一直持续到程序结束。生存期较短对象的比例通常在 80%～90% 之间，这种思想简单点说就是：对象存在时间越长，越可能不是垃圾，应该越少去收集。这样在执行标记-清除算法时可以有效减小遍历的对象数，从而提高垃圾回收的速度。 Python默认定义了三代对象集合，索引数越大，对象存活时间越长12345678910#define NUM_GENERATIONS 3#define GEN_HEAD(n) (&amp;generations[n].head)/* linked lists of container objects */static struct gc_generation generations[NUM_GENERATIONS] = &#123; /* PyGC_Head, threshold, count */ &#123;&#123;&#123;GEN_HEAD(0), GEN_HEAD(0), 0&#125;&#125;, 700, 0&#125;, &#123;&#123;&#123;GEN_HEAD(1), GEN_HEAD(1), 0&#125;&#125;, 10, 0&#125;, &#123;&#123;&#123;GEN_HEAD(2), GEN_HEAD(2), 0&#125;&#125;, 10, 0&#125;,&#125;; 新生成的对象会被加入第0代，前面_PyObject_GC_Malloc中省略的部分就是Python GC触发的时机。每新生成一个对象都会检查第0代有没有满，如果满了就开始着手进行垃圾回收.1234567891011g-&gt;gc.gc_refs = GC_UNTRACKED; generations[0].count++; /* number of allocated GC objects */ if (generations[0].count &gt; generations[0].threshold &amp;&amp; enabled &amp;&amp; generations[0].threshold &amp;&amp; !collecting &amp;&amp; !PyErr_Occurred()) &#123; collecting = 1; collect_generations(); collecting = 0; &#125; 3.1 在Python中的零代(Generation Zero)很多时候你的代码也许会在不经意间包含循环引用并且你并未意识到。事实上，当你的Python程序运行的时候它将会建立一定数量的“浮点数垃圾”，Python的GC不能够处理未使用的对象因为应用计数值不会到零。就是为什么Python要引入Generational GC算法的原因！正如Ruby使用一个链表(free list)来持续追踪未使用的、自由的对象一样，Python使用一种不同的链表来持续追踪活跃的对象。而不将其称之为“活跃列表”，Python的内部C代码将其称为零代(Generation Zero)。每次当你创建一个对象或其他什么值的时候，Python会将其加入零代链表。请注意到这并不是一个真正的列表，并不能直接在你的代码中访问，事实上这个链表是一个完全内部的Python运行体 3.2 Python中的GC阈值随着你的程序运行，Python解释器保持对新创建的对象，以及因为引用计数为零而被释放掉的对象的追踪。从理论上说，这两个值应该保持一致，因为程序新建的每个对象都应该最终被释放掉。 当然，事实并非如此。因为循环引用的原因，并且因为你的程序使用了一些比其他对象存在时间更长的对象，从而被分配对象的计数值与被释放对象的计数值之间的差异在逐渐增长。一旦这个差异累计超过某个阈值，则Python的收集机制就启动了，并且触发上边所说到的零代算法，释放“浮动的垃圾”，并且将剩下的对象移动到一代列表。 随着时间的推移，程序所使用的对象逐渐从零代列表移动到一代列表。而Python对于一代列表中对象的处理遵循同样的方法，一旦被分配计数值与被释放计数值累计到达一定阈值，Python会将剩下的活跃对象移动到二代列表。 通过这种方法，你的代码所长期使用的对象，那些你的代码持续访问的活跃对象，会从零代链表转移到一代再转移到二代。通过不同的阈值设置，Python可以在不同的时间间隔处理这些对象。Python处理零代最为频繁，其次是一代然后才是二代。 3.3 弱代假说来看看代垃圾回收算法的核心行为：垃圾回收器会更频繁的处理新对象。一个新的对象即是你的程序刚刚创建的，而一个来的对象则是经过了几个时间周期之后仍然存在的对象。Python会在当一个对象从零代移动到一代，或是从一代移动到二代的过程中提升(promote)这个对象。 为什么要这么做？这种算法的根源来自于弱代假说(weak generational hypothesis)。这个假说由两个观点构成：首先是年亲的对象通常死得也快，而老对象则很有可能存活更长的时间。 假定现在我用Python或是Ruby创建一个新对象 n1=”ABC”： 根据假说，我的代码很可能仅仅会使用ABC很短的时间。这个对象也许仅仅只是一个方法中的中间结果，并且随着方法的返回这个对象就将变成垃圾了。大部分的新对象都是如此般地很快变成垃圾。然而，偶尔程序会创建一些很重要的，存活时间比较长的对象-例如web应用中的session变量或是配置项。 通过频繁的处理零代链表中的新对象，Python的垃圾收集器将把时间花在更有意义的地方：它处理那些很快就可能变成垃圾的新对象。同时只在很少的时候，当满足阈值的条件，收集器才回去处理那些老变量。 分代回收的逻辑分配内存-&gt; 发现超过阈值了-&gt; 触发垃圾回收-&gt; 将所有可收集对象链表放到一起-&gt; 遍历, 计算有效引用计数-&gt; 分成 有效引用计数=0 和 有效引用计数 &gt; 0 两个集合-&gt; 大于0的, 放入到更老一代-&gt; =0的, 执行回收-&gt; 回收遍历容器内的各个元素, 减掉对应元素引用计数(破掉循环引用)-&gt; 执行-1的逻辑, 若发现对象引用计数=0, 触发内存回收-&gt; python底层内存管理机制回收内存 总结总体来说，在Python中，主要通过引用计数进行垃圾回收；通过 “标记-清除” 解决容器对象可能产生的循环引用问题；通过 “分代回收” 以空间换时间的方法提高垃圾回收效率。 参考文章：一文搞定Python垃圾回收机制Python垃圾回收机制–完美讲解!Python中的垃圾回收机制PYTHON 源码阅读 - 垃圾回收机制《垃圾回收的算法与实现》","categories":[{"name":"python","slug":"python","permalink":"https://liangweijiang.github.io/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://liangweijiang.github.io/tags/python/"},{"name":"垃圾回收","slug":"垃圾回收","permalink":"https://liangweijiang.github.io/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"}]},{"title":"每日一道算法之--有效的括号","slug":"algorithm-20","date":"2020-03-03T11:41:23.245Z","updated":"2020-03-03T11:42:43.389Z","comments":true,"path":"2020/03/03/algorithm-20/","link":"","permalink":"https://liangweijiang.github.io/2020/03/03/algorithm-20/","excerpt":"","text":"有效的括号力扣第20题 : https://leetcode-cn.com/problems/valid-parentheses/ 给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。 有效字符串需满足： 左括号必须用相同类型的右括号闭合。左括号必须以正确的顺序闭合。注意空字符串可被认为是有效字符串。 示例 1: 输入: “()”输出: true 示例 2: 输入: “()[]{}”输出: true 示例 3: 输入: “(]”输出: false 题目分析题目不难理解,就是括号要一一对应,换句话来说,只要出现了右括号,name就必定有一个左括号与之对应,而且左括号和右括号必须是对称的,刚好栈这种数据结构可以很好地实现这一目的. 要想一一对应,字符串长度必须是偶数 遍历这个数组,每当遇到左括号时,直接入栈 当遇到有括号时,就取出栈顶元素,然后与该括号配对,若配对失败,则证明字符串无效,若配对成功,则继续遍历 直到数组遍历完成并且栈里没有元素以后,则证明字符串有效 翻译成代码如下: 123456789101112class Solution: def isValid(self, s: str) -&gt; bool: has_map = &#123;')':'(', '&#125;':'&#123;', ']':'['&#125; stack = [] if len(s) % 2 != 0: return False for char in s: if char in has_map: top_ele = stack.pop() if stack else '' if top_ele != has_map[char]: return False else: stack.append(char) return not stack 复杂度分析时间复杂度：因为我们一次只遍历给定的字符串中的一个字符并在栈上进行 O(1) 的推入和弹出操作,所以时间复杂度为O(n)。 空间复杂度：在最糟糕的情况下，我们最终要把所有括号推到栈上。例如 ((((((((((, 而如果是有效字符串,则也要将n/2的括号入栈,所以空间复杂度为O(n)。","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://liangweijiang.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"栈","slug":"栈","permalink":"https://liangweijiang.github.io/tags/%E6%A0%88/"},{"name":"数组","slug":"数组","permalink":"https://liangweijiang.github.io/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"每日一道算法之--二叉树的层次遍历","slug":"algorithm-102","date":"2020-03-03T09:46:49.296Z","updated":"2020-03-03T10:35:03.161Z","comments":true,"path":"2020/03/03/algorithm-102/","link":"","permalink":"https://liangweijiang.github.io/2020/03/03/algorithm-102/","excerpt":"","text":"二叉树的层次遍历力扣第102题 : https://leetcode-cn.com/problems/binary-tree-level-order-traversal/ 给定一个二叉树，返回其按层次遍历的节点值。 （即逐层地，从左到右访问所有节点）。 例如: 给定二叉树: [3,9,20,null,null,15,7], 3 / 9 20 / 15 7 返回其层次遍历结果： [ [3], [9,20], [15,7]] 1.递归一开始看到这题时,因为之前学过二叉树的知识,所以我知道这道题的第一思路就是递归但是这道层次遍历的主要问题就是,数是分左右节点的,如果直接递归,那么同一层的左右节点就不会给同时读取.所以,能不能先定义一个变量,专门记录该节点的层级.然后分析题目的返回值,它是一个子元素是列表的列表,不难发现,子元素的索引,刚好就是数的层级,所以可以直接定义一个列表levels = [],每递归一层,如果大列表中没有该层级的子列表,就往大列表中添加一个字列表,然后往该层级的子列表中添加该节点的值代码如下: 12345678910111213141516171819202122# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def levelOrder(self, root: TreeNode) -&gt; List[List[int]]: levels= [] if not root : return levels def foo(node, level): n = len(levels) if n == level: levels.append([]) levels[level].append(node.val) if node.left: foo(node.left, level + 1) if node.right: foo(node.right, level + 1) foo(root, 0) return levels 1.1 复杂度分析时间复杂度:假设有n个节点,恰好会递归到每一个节点,所以时间复杂度为O(n) 空间复杂度:假设有n个节点,数组存储的刚好是每一个节点,所以空间复杂度为O(n) 2.迭代实现了递归的方式后,迭代的思想节本和递归差不多,只是要加多一个栈的数据结构 12345678910111213141516class Solution: def levelOrder(self, root: TreeNode) -&gt; List[List[int]]: levels = [] stack = [] if not root: return levels stack.append((root, 0)) while stack: node, level = stack.pop() if level == len(levels): levels.append([]) levels[level].append(node.val) if node.right: stack.append((node.right, level + 1)) if node.left: stack.append((node.left, level + 1)) return levels 2.1 复杂度分析时间复杂度：假设有n个节点,恰好会递归到每一个节点,因为每个节点恰好会被运算一次,所以时间复杂度为O(n) 空间复杂度：假设有n个节点,数组存储的刚好是每一个节点,栈的存储也是每一个节点,所以空间复杂度为O(n)+O(n) = O(n) 总结这道题考察的就是树的遍历,和前后序遍历差不错,但是就是加多了一个变量来记录层级,还是那句话,多加练习,多加练习!!!!!!","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://liangweijiang.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"递归","slug":"递归","permalink":"https://liangweijiang.github.io/tags/%E9%80%92%E5%BD%92/"},{"name":"树的遍历","slug":"树的遍历","permalink":"https://liangweijiang.github.io/tags/%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/"}]},{"title":"每日一道算法之--链表反转","slug":"algorithm-206","date":"2020-03-02T10:10:34.816Z","updated":"2020-03-02T10:32:34.192Z","comments":true,"path":"2020/03/02/algorithm-206/","link":"","permalink":"https://liangweijiang.github.io/2020/03/02/algorithm-206/","excerpt":"","text":"反转链表力扣第206题:https://leetcode-cn.com/problems/reverse-linked-list/submissions/ 反转一个单链表。 示例: 输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL 进阶:你可以迭代或递归地反转链表。你能否用两种方法解决这道题？ 1.递归解决1.1 创建新的节点一开始的时候我的想法是,既然是反转链表,那就可以创建一个新的节点来重新存储,然后直接递归到最后的节点,在不断地回溯中将新节点指向回溯的节点. 123456789101112131415161718192021# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: new_node = ListNode(0) n = new_node def reverseList(self, head: ListNode) -&gt; ListNode: if not head:return head def foo(head): if not head.next: return head node = foo(head.next) if node: self.n.next = ListNode(node.val) self.n = self.n.next return head foo(head) self.n.next = ListNode(head.val) return self.new_node.next 在测试了几个例子都行的通,我就很兴奋的提交了,结果哦吼,提交时间超时…… 1.2 在原链表处理我就在找原因,有可能是因为创建了新节点,处理时间太长,能不能不用新的节点,直接在原本的链表中去改变指针的指向,当获取到最后的节点时直接处理该节点 逐步递归,知道获取到最后的节点 递归回退的时候,一次改变节点的指针,使该节点的下下个指针指向自己,即node.next.next = node 注意的是,要将该节点的下一个指针删除,一开始我没注意,看了官方题解才知道 1234567class Solution: def reverseList(self, head: ListNode) -&gt; ListNode: if not head or not head.next: return head node = self.reverseList(head.next) head.next.next = head; head.next = None; return node 1.3 复杂度分析时间复杂度：O(n)，假设 n 是列表的长度，要层层递归,那么时间复杂度为 O(n)。 空间复杂度：O(n)，由于使用递归，将会使用隐式栈空间。递归深度可能会达到 nn 层。 2.迭代实现1.1 用栈实现因为栈是先进先出的数据结构,所以先用栈存储每一个节点,然后在依次取出操作 12345678910111213class Solution: def reverseList(self, head: ListNode) -&gt; ListNode: if not head or not head.next: return head stack = [] while head: stack.append(head) head = head.next n = stack.pop() while stack: node = stack.pop() node.next.next = node node.next = None return n 1.1.1 复杂度分析时间复杂度:假设列表长度为n, 进栈的时间复杂度为O(n),出栈的时间复杂度同样为O(n),所以时间复杂度为2*O(n) = O(n) 空间复杂度为:运用了栈的数据结构,所以空间复杂度为O(n)可以看到效率还是不错的 2.2 官方的双指针解法当我们要反转一个链表时,只需要改变每一个节点的前驱和后继指针 12345678910class Solution: def reverseList(self, head: ListNode) -&gt; ListNode: if not head: return None prev &#x3D; None cur &#x3D; head while cur: cur.next&#x3D; prev prev &#x3D; cur cur &#x3D; cur.next return prev 2.2.1 复杂度分析时间复杂度:O(n) 空间复杂度为:O(n)","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://liangweijiang.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"链表","slug":"链表","permalink":"https://liangweijiang.github.io/tags/%E9%93%BE%E8%A1%A8/"},{"name":"递归","slug":"递归","permalink":"https://liangweijiang.github.io/tags/%E9%80%92%E5%BD%92/"}]},{"title":"每日一道算法之--股票问题总结","slug":"algorithm-stock","date":"2020-03-02T07:31:24.558Z","updated":"2020-03-02T10:32:55.199Z","comments":true,"path":"2020/03/02/algorithm-stock/","link":"","permalink":"https://liangweijiang.github.io/2020/03/02/algorithm-stock/","excerpt":"","text":"股票问题总结最近在leetcode刷题的时候发现了一个很好的解决股票问题的题解,所以收藏了这个链接,他主要运用了状态机的思想,从而非常有效的解决股票等dp问题 文章如下: 本文参考自英文版LeetCode：https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/discuss/108870/Most-consistent-ways-of-dealing-with-the-series-of-stock-problems 很多读者抱怨股票系列问题奇技淫巧太多，如果面试真的遇到这类问题，基本不会想到那些巧妙的办法，怎么办？所以本文拒绝奇技淫巧，而是稳扎稳打，只用一种通用方法解决所用问题，以不变应万变。 这篇文章用状态机的技巧来解决，可以全部提交通过。不要觉得这个名词高大上，文学词汇而已，实际上就是 DP table，看一眼就明白了。 先随便抽出一道题，看看别人的解法： 123456789101112int maxProfit(vector&lt;int&gt;&amp; prices) &#123; if(prices.empty()) return 0; int s1=-prices[0],s2=INT_MIN,s3=INT_MIN,s4=INT_MIN; for(int i=1;i&lt;prices.size();++i) &#123; s1 = max(s1, -prices[i]); s2 = max(s2, s1+prices[i]); s3 = max(s3, s2-prices[i]); s4 = max(s4, s3+prices[i]); &#125; return max(0,s4);&#125; 能看懂吧？会做了吗？不可能的，你看不懂，这才正常。就算你勉强看懂了，下一个问题你还是做不出来。为什么别人能写出这么诡异却又高效的解法呢？因为这类问题是有框架的，但是人家不会告诉你的，因为一旦告诉你，你五分钟就学会了，该算法题就不再神秘，变得不堪一击了。 本文就来告诉你这个框架，然后带着你一道一道秒杀。 这 6 道股票买卖问题是有共性的，我们通过对第四题（限制最大交易次数为 k）的分析一道一道解决。因为第四题是一个最泛化的形式，其他的问题都是这个形式的简化。 第一题是只进行一次交易，相当于 k = 1；第二题是不限交易次数，相当于 k = +infinity（正无穷）；第三题是只进行 2 次交易，相当于 k = 2；剩下两道也是不限次数，但是加了交易「冷冻期」和「手续费」的额外条件，其实就是第二题的变种，都很容易处理。 一、穷举框架首先，还是一样的思路：如何穷举？这里的穷举思路和上篇文章递归的思想不太一样。 递归其实是符合我们思考的逻辑的，一步步推进，遇到无法解决的就丢给递归，一不小心就做出来了，可读性还很好。缺点就是一旦出错，你也不容易找到错误出现的原因。比如上篇文章的递归解法，肯定还有计算冗余，但确实不容易找到。 而这里，我们不用递归思想进行穷举，而是利用「状态」进行穷举。我们具体到每一天，看看总共有几种可能的「状态」，再找出每个「状态」对应的「选择」。我们要穷举所有「状态」，穷举的目的是根据对应的「选择」更新状态。听起来抽象，你只要记住「状态」和「选择」两个词就行，下面实操一下就很容易明白了。 1234for 状态1 in 状态1的所有取值： for 状态2 in 状态2的所有取值： for ... dp[状态1][状态2][...] = 择优(选择1，选择2...) 比如说这个问题，每天都有三种「选择」：买入、卖出、无操作，我们用 buy, sell, rest 表示这三种选择。但问题是，并不是每天都可以任意选择这三种选择的，因为 sell 必须在 buy 之后，buy 必须在 sell 之后。那么 rest 操作还应该分两种状态，一种是 buy 之后的 rest（持有了股票），一种是 sell 之后的 rest（没有持有股票）。而且别忘了，我们还有交易次数 k 的限制，就是说你 buy 还只能在 k &gt; 0 的前提下操作。 很复杂对吧，不要怕，我们现在的目的只是穷举，你有再多的状态，老夫要做的就是一把梭全部列举出来。这个问题的「状态」有三个，第一个是天数，第二个是允许交易的最大次数，第三个是当前的持有状态（即之前说的 rest 的状态，我们不妨用 1 表示持有，0 表示没有持有）。然后我们用一个三维数组就可以装下这几种状态的全部组合： 123456789dp[i][k][0 or 1]0 &lt;= i &lt;= n-1, 1 &lt;= k &lt;= Kn 为天数，大 K 为最多交易数此问题共 n × K × 2 种状态，全部穷举就能搞定。for 0 &lt;= i &lt; n: for 1 &lt;= k &lt;= K: for s in &#123;0, 1&#125;: dp[i][k][s] = max(buy, sell, rest) 而且我们可以用自然语言描述出每一个状态的含义，比如说 dp[3][2][1] 的含义就是：今天是第三天，我现在手上持有着股票，至今最多进行 2 次交易。再比如 dp[2][3][0] 的含义：今天是第二天，我现在手上没有持有股票，至今最多进行 3 次交易。很容易理解，对吧？ 我们想求的最终答案是 dp[n - 1][K][0]，即最后一天，最多允许 K 次交易，最多获得多少利润。读者可能问为什么不是 dp[n - 1][K][1]？因为 [1] 代表手上还持有股票，[0] 表示手上的股票已经卖出去了，很显然后者得到的利润一定大于前者。 记住如何解释「状态」，一旦你觉得哪里不好理解，把它翻译成自然语言就容易理解了。 二、状态转移框架现在，我们完成了「状态」的穷举，我们开始思考每种「状态」有哪些「选择」，应该如何更新「状态」。只看「持有状态」，可以画个状态转移图。 123456789101112131415通过这个图可以很清楚地看到，每种状态（0 和 1）是如何转移而来的。根据这个图，我们来写一下状态转移方程：dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]) max( 选择 rest , 选择 sell )解释：今天我没有持有股票，有两种可能：要么是我昨天就没有持有，然后今天选择 rest，所以我今天还是没有持有；要么是我昨天持有股票，但是今天我 sell 了，所以我今天没有持有股票了。dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]) max( 选择 rest , 选择 buy )解释：今天我持有着股票，有两种可能：要么我昨天就持有着股票，然后今天选择 rest，所以我今天还持有着股票；要么我昨天本没有持有，但今天我选择 buy，所以今天我就持有股票了。 这个解释应该很清楚了，如果 buy，就要从利润中减去 prices[i]，如果 sell，就要给利润增加 prices[i]。今天的最大利润就是这两种可能选择中较大的那个。而且注意 k 的限制，我们在选择 buy 的时候，把 k 减小了 1，很好理解吧，当然你也可以在 sell 的时候减 1，一样的。 现在，我们已经完成了动态规划中最困难的一步：状态转移方程。如果之前的内容你都可以理解，那么你已经可以秒杀所有问题了，只要套这个框架就行了。不过还差最后一点点，就是定义 base case，即最简单的情况。 12345678dp[-1][k][0] = 0解释：因为 i 是从 0 开始的，所以 i = -1 意味着还没有开始，这时候的利润当然是 0 。dp[-1][k][1] = -infinity解释：还没开始的时候，是不可能持有股票的，用负无穷表示这种不可能。dp[i][0][0] = 0解释：因为 k 是从 1 开始的，所以 k = 0 意味着根本不允许交易，这时候利润当然是 0 。dp[i][0][1] = -infinity解释：不允许交易的情况下，是不可能持有股票的，用负无穷表示这种不可能。 把上面的状态转移方程总结一下： 12345678base case：dp[-1][k][0] = dp[i][0][0] = 0dp[-1][k][1] = dp[i][0][1] = -infinity状态转移方程：dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])读者可能会问，这个数组索引是 -1 怎么编程表示出来呢，负无穷怎么表示呢？这都是细节问题，有很多方法实现。现在完整的框架已经完成，下面开始具体化。 三、秒杀题目第一题，k = 1直接套状态转移方程，根据 base case，可以做一些化简： 123456789dp[i][1][0] = max(dp[i-1][1][0], dp[i-1][1][1] + prices[i])dp[i][1][1] = max(dp[i-1][1][1], dp[i-1][0][0] - prices[i]) = max(dp[i-1][1][1], -prices[i])解释：k = 0 的 base case，所以 dp[i-1][0][0] = 0。现在发现 k 都是 1，不会改变，即 k 对状态转移已经没有影响了。可以进行进一步化简去掉所有 k：dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])dp[i][1] = max(dp[i-1][1], -prices[i]) 直接写出代码： 1234567int n = prices.length;int[][] dp = new int[n][2];for (int i = 0; i &lt; n; i++) &#123; dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1] + prices[i]); dp[i][1] = Math.max(dp[i-1][1], -prices[i]);&#125;return dp[n - 1][0]; 显然 i = 0 时 dp[i-1] 是不合法的。这是因为我们没有对 i 的 base case 进行处理。可以这样处理： 12345678910111213141516171819for (int i = 0; i &lt; n; i++) &#123; if (i - 1 == -1) &#123; dp[i][0] = 0; // 解释： // dp[i][0] // = max(dp[-1][0], dp[-1][1] + prices[i]) // = max(0, -infinity + prices[i]) = 0 dp[i][1] = -prices[i]; //解释： // dp[i][1] // = max(dp[-1][1], dp[-1][0] - prices[i]) // = max(-infinity, 0 - prices[i]) // = -prices[i] continue; &#125; dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1] + prices[i]); dp[i][1] = Math.max(dp[i-1][1], -prices[i]);&#125;return dp[n - 1][0]; 第一题就解决了，但是这样处理 base case 很麻烦，而且注意一下状态转移方程，新状态只和相邻的一个状态有关，其实不用整个 dp 数组，只需要一个变量储存相邻的那个状态就足够了，这样可以把空间复杂度降到 O(1): 12345678910111213// k == 1int maxProfit_k_1(int[] prices) &#123; int n = prices.length; // base case: dp[-1][0] = 0, dp[-1][1] = -infinity int dp_i_0 = 0, dp_i_1 = Integer.MIN_VALUE; for (int i = 0; i &lt; n; i++) &#123; // dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i]) dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]); // dp[i][1] = max(dp[i-1][1], -prices[i]) dp_i_1 = Math.max(dp_i_1, -prices[i]); &#125; return dp_i_0;&#125; 两种方式都是一样的，不过这种编程方法简洁很多。但是如果没有前面状态转移方程的引导，是肯定看不懂的。后续的题目，我主要写这种空间复杂度 O(1) 的解法。 第二题，k = +infinity如果 k 为正无穷，那么就可以认为 k 和 k - 1 是一样的。可以这样改写框架： 1234567dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]) = max(dp[i-1][k][1], dp[i-1][k][0] - prices[i])我们发现数组中的 k 已经不会改变了，也就是说不需要记录 k 这个状态了：dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i]) 直接翻译成代码： 12345678910int maxProfit_k_inf(int[] prices) &#123; int n = prices.length; int dp_i_0 = 0, dp_i_1 = Integer.MIN_VALUE; for (int i = 0; i &lt; n; i++) &#123; int temp = dp_i_0; dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]); dp_i_1 = Math.max(dp_i_1, temp - prices[i]); &#125; return dp_i_0;&#125; 第三题，k = +infinity with cooldown每次 sell 之后要等一天才能继续交易。只要把这个特点融入上一题的状态转移方程即可： 1234567891011121314151617dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])dp[i][1] = max(dp[i-1][1], dp[i-2][0] - prices[i])解释：第 i 天选择 buy 的时候，要从 i-2 的状态转移，而不是 i-1 。翻译成代码：int maxProfit_with_cool(int[] prices) &#123; int n = prices.length; int dp_i_0 = 0, dp_i_1 = Integer.MIN_VALUE; int dp_pre_0 = 0; // 代表 dp[i-2][0] for (int i = 0; i &lt; n; i++) &#123; int temp = dp_i_0; dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]); dp_i_1 = Math.max(dp_i_1, dp_pre_0 - prices[i]); dp_pre_0 = temp; &#125; return dp_i_0;&#125; 第四题，k = +infinity with fee每次交易要支付手续费，只要把手续费从利润中减去即可。改写方程： 12345678910111213141516dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i] - fee)解释：相当于买入股票的价格升高了。在第一个式子里减也是一样的，相当于卖出股票的价格减小了。直接翻译成代码：int maxProfit_with_fee(int[] prices, int fee) &#123; int n = prices.length; int dp_i_0 = 0, dp_i_1 = Integer.MIN_VALUE; for (int i = 0; i &lt; n; i++) &#123; int temp = dp_i_0; dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]); dp_i_1 = Math.max(dp_i_1, temp - prices[i] - fee); &#125; return dp_i_0;&#125; 第五题，k = 2k = 2 和前面题目的情况稍微不同，因为上面的情况都和 k 的关系不太大。要么 k 是正无穷，状态转移和 k 没关系了；要么 k = 1，跟 k = 0 这个 base case 挨得近，最后也没有存在感。 这道题 k = 2 和后面要讲的 k 是任意正整数的情况中，对 k 的处理就凸显出来了。我们直接写代码，边写边分析原因。 原始的动态转移方程，没有可化简的地方 12dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]) 按照之前的代码，我们可能想当然这样写代码（错误的）： 12345678int k = 2;int[][][] dp = new int[n][k + 1][2];for (int i = 0; i &lt; n; i++) if (i - 1 == -1) &#123; /* 处理一下 base case*/ &#125; dp[i][k][0] = Math.max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]); dp[i][k][1] = Math.max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]);&#125;return dp[n - 1][k][0]; 为什么错误？我这不是照着状态转移方程写的吗？ 还记得前面总结的「穷举框架」吗？就是说我们必须穷举所有状态。其实我们之前的解法，都在穷举所有状态，只是之前的题目中 k 都被化简掉了。这道题由于没有消掉 k 的影响，所以必须要对 k 进行穷举： 12345678910111213141516int max_k = 2;int[][][] dp = new int[n][max_k + 1][2];for (int i = 0; i &lt; n; i++) &#123; for (int k = max_k; k &gt;= 1; k--) &#123; if (i - 1 == -1) &#123; /* 处理 base case */ dp[i][k][0] = 0; dp[i][k][1] = -prices[i]; continue; &#125; dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]); dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]); &#125;&#125;// 穷举了 n × max_k × 2 个状态，正确。return dp[n - 1][max_k][0]; 如果你不理解，可以返回第一点「穷举框架」重新阅读体会一下。 这里 k 取值范围比较小，所以可以不用 for 循环，直接把 k = 1 和 2 的情况手动列举出来也可以： 12345678910111213141516dp[i][2][0] = max(dp[i-1][2][0], dp[i-1][2][1] + prices[i])dp[i][2][1] = max(dp[i-1][2][1], dp[i-1][1][0] - prices[i])dp[i][1][0] = max(dp[i-1][1][0], dp[i-1][1][1] + prices[i])dp[i][1][1] = max(dp[i-1][1][1], -prices[i])int maxProfit_k_2(int[] prices) &#123; int dp_i10 = 0, dp_i11 = Integer.MIN_VALUE; int dp_i20 = 0, dp_i21 = Integer.MIN_VALUE; for (int price : prices) &#123; dp_i20 = Math.max(dp_i20, dp_i21 + price); dp_i21 = Math.max(dp_i21, dp_i10 - price); dp_i10 = Math.max(dp_i10, dp_i11 + price); dp_i11 = Math.max(dp_i11, -price); &#125; return dp_i20;&#125; 有状态转移方程和含义明确的变量名指导，相信你很容易看懂。其实我们可以故弄玄虚，把上述四个变量换成 a, b, c, d。这样当别人看到你的代码时就会一头雾水，大惊失色，不得不对你肃然起敬。 第六题，k = any integer有了上一题 k = 2 的铺垫，这题应该和上一题的第一个解法没啥区别。但是出现了一个超内存的错误，原来是传入的 k 值会非常大，dp 数组太大了。现在想想，交易次数 k 最多有多大呢？ 一次交易由买入和卖出构成，至少需要两天。所以说有效的限制 k 应该不超过 n/2，如果超过，就没有约束作用了，相当于 k = +infinity。这种情况是之前解决过的。 直接把之前的代码重用： 12345678910111213141516171819int maxProfit_k_any(int max_k, int[] prices) &#123; int n = prices.length; if (max_k &gt; n / 2) return maxProfit_k_inf(prices); int[][][] dp = new int[n][max_k + 1][2]; for (int i = 0; i &lt; n; i++) for (int k = max_k; k &gt;= 1; k--) &#123; if (i - 1 == -1) &#123; /* 处理 base case */ dp[i][k][0] = 0; dp[i][k][1] = -prices[i]; continue; &#125; dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]); dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]); &#125; return dp[n - 1][max_k][0];&#125; 至此，6 道题目通过一个状态转移方程全部解决。 四、最后总结本文给大家讲了如何通过状态转移的方法解决复杂的问题，用一个状态转移方程秒杀了 6 道股票买卖问题，现在想想，其实也不算难对吧？这已经属于动态规划问题中较困难的了。 关键就在于列举出所有可能的「状态」，然后想想怎么穷举更新这些「状态」。一般用一个多维 dp 数组储存这些状态，从 base case 开始向后推进，推进到最后的状态，就是我们想要的答案。想想这个过程，你是不是有点理解「动态规划」这个名词的意义了呢？ 具体到股票买卖问题，我们发现了三个状态，使用了一个三维数组，无非还是穷举 + 更新，不过我们可以说的高大上一点，这叫「三维 DP」，怕不怕？这个大实话一说，立刻显得你高人一等，名利双收有没有。 所以，大家不要被各种高大上的名词吓到，再多的困难问题，奇技淫巧，也不过是基本套路的不断升级组合产生的。只要把住算法的底层原理，即可举一反三，逐个击破。 买卖股票的最佳时机 买卖股票的最佳时机 II 买卖股票的最佳时机 III 买卖股票的最佳时机 IV 最佳买卖股票时机含冷冻期 买卖股票的最佳时机含手续费 作者：labuladong链接：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/solution/yi-ge-fang-fa-tuan-mie-6-dao-gu-piao-wen-ti-by-l-3/来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://liangweijiang.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://liangweijiang.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"状态机","slug":"状态机","permalink":"https://liangweijiang.github.io/tags/%E7%8A%B6%E6%80%81%E6%9C%BA/"}]},{"title":"每日一道算法之--无重复的最长的子字符串","slug":"algorithm-3","date":"2020-02-29T08:59:16.674Z","updated":"2020-03-11T12:30:29.188Z","comments":true,"path":"2020/02/29/algorithm-3/","link":"","permalink":"https://liangweijiang.github.io/2020/02/29/algorithm-3/","excerpt":"","text":"无重复的最长的子字符串力扣第3题:https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/ 1 暴力解决暴力方法就是将所有的肯恩列举出来,在会超过时间限制,这里就不列举了 2 滑动窗口这道题是我第一道碰到的滑动窗口的题目,当时想了很久都想不出来,后来去看一一下别人的题解恍然大悟,滑动窗口确实是解决字符串问题的一非常好的方法 滑动窗口的顾名思义就是可以滑动的数据结构,遍历整个字符串,当滑动窗口里没有该字符时,就将该字符加进滑动窗口 当遇到有重复字符时,要将滑动窗口该字符前面的的字符(包括该字符)全部去除,然后在将该字符加进滑动窗口 代码如下: 1234567891011121314151617181920class Solution: def lengthOfLongestSubstring(self, s: str) -&gt; int: # 集合可以保证唯一性 silde_win = set() # 设置滑动窗口的值 left = 0 # 记录最长子串的长度 max_len = 0 # 记录当前的子串长度 cur_len = 0 for i in range(len(s)): cur_len += 1 # 设置滑动窗口的值 while s[i] in silde_win: silde_win.remove(s[left]) left += 1 cur_len -= 1 silde_win.add(s[i]) max_len = max(max_len, cur_len) return max_len 2.1 复杂度分析时间复杂度:遍历了一次数组,时间复杂度为$$0(N)$$, 但是每次滑动窗口的都有重复字符,如字符串为’aaaaaaaaaaaaaaaaaaa’,会浪费没必要的时间,但是均摊时间复杂度依然为$$O(N)$$ 空间复杂度:用了集合,所以空间复杂度为$$O(N)$$ 滑动窗口的优化可以看到提交的成绩不是很理想,所以我一直在想着怎么优化,想到了几个优化方法 如果字符串有相邻的子串,直接忽视123456789101112131415161718192021222324class Solution: def lengthOfLongestSubstring(self, s: str) -&gt; int: if not s :return 0 silde_win = set() left = 0 max_len = 0 cur_len = 0 for i in range(len(s)): # 如果字符串有相邻的子串,直接忽视 if i &gt; 0 and s[i-1] == s[i]: silde_win = set() silde_win.add(s[i]) left = i cur_len = 1 continue cur_len += 1 # 设置滑动窗口的值 while s[i] in silde_win: silde_win.remove(s[left]) left += 1 cur_len -= 1 silde_win.add(s[i]) max_len = max(max_len, cur_len) return max_len 可以发现成绩有了提升,但不是很明显 然后在看看我么你写的代码,silde_win这个数据结构其实是有很多操作的,话费了很多时间,换个思路想一想,我们能又能用更好地数据结构来代替这个集合呢,其实这个滑动窗口只是一个辅助的数据结构,只是用来暂时存储字符串的字串的,那为什么不直接用分片呢 123456789101112131415161718192021class Solution: def lengthOfLongestSubstring(self, s: str) -&gt; int: if not s :return 0 # 设置滑动窗口的值 left = 0 # 记录最长子串的长度 max_len = 0 # 记录当前的子串长度 cur_len = 0 for i in range(len(s)): if i &gt; 0 and s[i-1] == s[i]: left = i cur_len = 1 continue cur_len += 1 # 设置滑动窗口的值 while s[i] in s[left:i]: left += 1 cur_len -= 1 max_len = max(max_len, cur_len) return max_len 相似题目76.最小覆盖子串 159. 至多包含两个不同字符的最长子串 340. 至多包含 K 个不同字符的最长子串","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://liangweijiang.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"滑动窗口","slug":"滑动窗口","permalink":"https://liangweijiang.github.io/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"}]},{"title":"每日一道算法之--买卖股票的最佳时机","slug":"algorithm-121","date":"2020-02-29T07:25:08.775Z","updated":"2020-03-02T10:29:59.799Z","comments":true,"path":"2020/02/29/algorithm-121/","link":"","permalink":"https://liangweijiang.github.io/2020/02/29/algorithm-121/","excerpt":"","text":"买卖股票的最佳时机力扣第121题：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。 如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。 注意你不能在买入股票前卖出股票。 示例 1: 输入: [7,1,5,3,6,4]输出: 5解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。 注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。 示例 2： 输入: [7,6,4,3,1]输出: 0解释: 在这种情况下, 没有交易完成, 所以最大利润为 0 1 暴力方法暴力方法简单容易理解，只是两次循环把所有的可能一一列举出来。然后在取其中的最大值 12345678class Solution: def maxProfit(self, prices: List[int]) -&gt; int: max_profit = 0 for i in range(len(prices) - 1): for j in range(i + 1, len(prices)): profit = prices[j] - prices[i] max_profit = max(max_profit, profit) return max_profit 1.1 复杂度分析时间复杂度:循环里嵌套另一个循环,所里时间复杂度为$$O(N^2)$$ 空间复杂度:只使用了max_profit和profit两个变量,所以空间复杂度为$$O(1)$$ 2 动态规划遍历一次 由题意不难理解,当前最大的收益就是你当前的价格减去之前的最小价格,所以定义一个变量min_price存储之前的最小值,在定义一个变量max_profit存储最大的收益值,便可以达到遍历一次 状态转移方程为dp[i] = max(dp[i-1]+diff[i], 0), dp[i])指以i元素结尾的子数组的最大和 12345678class Solution: def maxProfit(self, prices: List[int]) -&gt; int: min_price = float('inf') max_profit = 0 for i in range(len(prices)): min_price = min(prices[i], min_price) max_profit = max(max_profit, prices[i]-min_price) return max_profit 2.1 复杂度分析时间复杂度:遍历了一次数组,所以时间复杂度为$$O(N)$$ 空间复杂度:只使用了min_price和max_profit两个变量,所以空间复杂度为$$O(1)$$","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://liangweijiang.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://liangweijiang.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"DRF源码解析6--权限组件的封装和初始化","slug":"DRF-06","date":"2020-02-26T09:55:17.825Z","updated":"2020-02-26T09:56:50.508Z","comments":true,"path":"2020/02/26/DRF-06/","link":"","permalink":"https://liangweijiang.github.io/2020/02/26/DRF-06/","excerpt":"","text":"1.权限组件的初始化在前面的版本控制和认证组件里提到的initia初始化函数, 同时也对权限组件进行了初始化 1234567def initial(self, request, *args, **kwargs): # 认证组件 self.perform_authentication(request) # 权限组件 self.check_permissions(request) # 频率 self.check_throttles(request) 1.1 check_permissions可以看到,check_permissions函数就是初始化权限组件的函数了 123456789 def check_permissions(self, request): for permission in self.get_permissions():# permission_denied函数抛出异常# 说明权限组件中必须包含has_permission的方法# 同时说明这是DRF框架给我们提供的自定义权限组件的钩子 if not permission.has_permission(request, self): self.permission_denied( request, message=getattr(permission, 'message', None) ) 1.2 get_permissions可以看出,权限组件在self.get_permissions方法中获取 12def get_permissions(self): return [permission() for permission in self.permission_classes] 可以看到,这个和认证组件的获取方法是一样的,只是没有认证组件那么绕 2. 权限组件的类型DRF提供的权限组件在rest_framework.permissions中,如下图可以看到, has_permission方法返回的是布尔类型 #总结DRF的权限组件比较简单,和认证组件大致一样","categories":[{"name":"django-rest-framework","slug":"django-rest-framework","permalink":"https://liangweijiang.github.io/categories/django-rest-framework/"}],"tags":[{"name":"DRF","slug":"DRF","permalink":"https://liangweijiang.github.io/tags/DRF/"}]},{"title":"每日一道算法之--乘积最大子序和","slug":"algorithm-152","date":"2020-02-26T09:08:00.357Z","updated":"2020-03-02T10:32:21.176Z","comments":true,"path":"2020/02/26/algorithm-152/","link":"","permalink":"https://liangweijiang.github.io/2020/02/26/algorithm-152/","excerpt":"","text":"乘积最大子序和力扣第152题:https://leetcode-cn.com/problems/maximum-product-subarray/给定一个整数数组 nums ，找出一个序列中乘积最大的连续子序列（该序列至少包含一个数）。 示例 1: 输入: [2,3,-2,4]输出: 6解释: 子数组 [2,3] 有最大乘积 6。 示例 2: 输入: [-2,0,-1]输出: 0解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。 1. 类似指针的解法参考力扣第53题最大子序和的其中一种双指针解法,这道题同样可以用类似指针的解法 首先定义一个res记录最大的子序和,cur_pos记录当前的乘积 然后cur_pos依次累乘, 每一次的结果都有三种情况: cur_pos等于0, 这时候要重新将指针偏移后一位 cur_pos大于0, 这时候要更新res的结果,就是和cur_pos比较大小 cur_pos小于0, 负负得正,需要找到指针前面最大的负数,相除就变为最大 12345678910111213141516171819202122232425262728class Solution: def maxProduct(self, nums: List[int]) -&gt; int: if not nums: return 0 # 目前的累乘 cur_pro = 1 # 前面最大的负数 max_neg = float(\"-inf\") # 结果 res = float(\"-inf\") for num in nums: cur_pro *= num # 考虑三种情况 # 大于0 if cur_pro &gt; 0: res = max(res, cur_pro) # 小于0 elif cur_pro &lt; 0: if max_neg != float(\"-inf\"): res = max(res, cur_pro // max_neg) else: res = max(res, num) max_neg = max(max_neg, cur_pro) # 等于0 else: cur_pro = 1 max_neg = float(\"-inf\") res = max(res, num) return res 1.1 复杂度分析时间复杂度:遍历整个数组的时间复杂度为O(N)空间复杂度:没有用到额外的数据结构,所以空间复杂度为O(1) 2. 动态规划解决不难发现,每一个元素的乘积,最大值只可能在自身或者自身与上一次的累乘之中公式如下: dp_max[i] = Math.max(nums[i-1],dp_max[i-1]*nums[i-1]) 因为存在负数,所以当这个元素为负数是,其最大乘积可能是与上一次最小乘积相乘所以不仅要定义一个变量存储最大当前的最大累乘,还要定义一个变量存储当前的最小累乘 12345678910111213141516class Solution: def maxProduct(self, nums: List[int]) -&gt; int: if not nums: return 0 # 存储最后的结果 res = nums[0] # 存储最大当前的最大累乘 res_max = nums[0] # 存储当前的最小累乘 res_min = nums[0] for num in nums[1:]: cur_max = max(res_max*num, res_min*num, num) cur_min = min(res_max*num, res_min*num, num) res = max(res, cur_max) res_max = cur_max res_min = cur_min return res 2.1 复杂度分析时间复杂度:遍历整个数组的时间复杂度为O(N)空间复杂度:没有用到额外的数据结构,所以空间复杂度为O(1)","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://liangweijiang.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://liangweijiang.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"指针","slug":"指针","permalink":"https://liangweijiang.github.io/tags/%E6%8C%87%E9%92%88/"}]},{"title":"DRF源码解析5--认证组件的封装和初始化","slug":"DRF-05","date":"2020-02-24T12:59:20.730Z","updated":"2020-02-26T09:41:53.685Z","comments":true,"path":"2020/02/24/DRF-05/","link":"","permalink":"https://liangweijiang.github.io/2020/02/24/DRF-05/","excerpt":"","text":"1.认证组件的初始化在对DRF的版本认证里说到,initial()不仅对版本认证组件进行了初始化,同时还初始化了认证组件,现在来分析一下DRF是怎么样初始化认证方法的 12def perform_authentication(self, request): request.user 可以看到,perform_authentication()方法返回了request(相当于封装的Request),进入request中找到uesr方法 1.1 截取Request部分代码如下:123456789101112131415161718192021222324252627class Request: def __init__(self, request, parsers=None, authenticators=None, negotiator=None, parser_context=None): assert isinstance(request, HttpRequest), ( 'The `request` argument must be an instance of ' '`django.http.HttpRequest`, not `&#123;&#125;.&#123;&#125;`.' .format(request.__class__.__module__, request.__class__.__name__) ) self._request = request self.parsers = parsers or () self.authenticators = authenticators or () self.negotiator = negotiator or self._default_negotiator() @property def user(self): if not hasattr(self, '_user'): with wrap_attributeerrors(): self._authenticate() return self._user @user.setter def user(self, value): # 当调用user时触发, 如user = 'xxx', 则value = 'xxx' self._user = value self._request.user = value 可以看到,user执行了self._authenticate方法,返回的_user为当前用户 截取self._authenticate的代码如下:12345678910111213 def _authenticate(self): for authenticator in self.authenticators: try:# 这里是调用默认的认证组件里的authenticate方法 user_auth_tuple = authenticator.authenticate(self) except exceptions.APIException: self._not_authenticated() raise if user_auth_tuple is not None: self._authenticator = authenticator self.user, self.auth = user_auth_tuple return self.authenticators为Request的属性,所以在init中可以找到 123def __init__(self, request, parsers=None, authenticators=None, negotiator=None, parser_context=None): self.authenticators = authenticators or () authenticators是作为参数传进来的,所以回到实例化Request的initialize_request方法中 12345678910def initialize_request(self, request, *args, **kwargs): parser_context = self.get_parser_context(request) return Request( request, parsers=self.get_parsers(), authenticators=self.get_authenticators(), negotiator=self.get_content_negotiator(), parser_context=parser_context ) 可以看到,authenticators传进了一个self.get_authenticators的方法 1.2 截取self.get_authenticators代码如下12def get_authenticators(self): return [auth() for auth in self.authentication_classes] 可以看到,get_authenticators方法返回了self.authentication_classes中所有auth的执行结果的一个列表, 而self.authentication_classes则为DRF中默认的认证组件 authenticate回到_authenticate方法中,现在已经知道authenticator是DRF默认的认证组件,则进去其authenticate方法中 12345678class ForcedAuthentication: def __init__(self, force_user, force_token): self.force_user = force_user self.force_token = force_token def authenticate(self, request): return (self.force_user, self.force_token) 其返回了self.force_user, self.force_token,分别为用户和验证用户信息的的token码,说明了认证组件都带有authenticate方法并且返回用户认证的信息 1.3 思路总结DRF认证组件的初始化主要分为两部分: 2. 认证组件的类型DRF提供的认证组件在rest_framework.authentication中 2.1 BaseAuthentication1234567class BaseAuthentication: def authenticate(self, request): raise NotImplementedError(\".authenticate() must be overridden.\") def authenticate_header(self, request): pass 可以看出,authenticate方法就是自定制认证组件的钩子函数 2.2 SessionAuthentication1234567891011121314151617181920212223242526class SessionAuthentication(BaseAuthentication): def authenticate(self, request): # 重写了authenticate方法并获取当前的用户信息 # Get the session-based user from the underlying HttpRequest object user = getattr(request._request, 'user', None) # Unauthenticated, CSRF validation not required if not user or not user.is_active: return None # 执行enforce_csrf方法判断用户的csrf_token是否正确 self.enforce_csrf(request) # CSRF passed with authenticated user return (user, None) def enforce_csrf(self, request): check = CSRFCheck() # populates request.META['CSRF_COOKIE'], which is used in process_view() # 中间件的process_request方法,拿取用户的CSRF_COOKIE check.process_request(request) # 认证用户的CSRF_COOKIE是否正确 reason = check.process_view(request, None, (), &#123;&#125;) if reason: # CSRF failed, bail with explicit error message raise exceptions.PermissionDenied('CSRF Failed: %s' % reason) 总结DRF的认证组件就是通过中间件等方法,获取当前用户的认证信息,在与本地的信息进行对比,从而达到认证用户的目的。","categories":[{"name":"django-rest-framework","slug":"django-rest-framework","permalink":"https://liangweijiang.github.io/categories/django-rest-framework/"}],"tags":[{"name":"DRF","slug":"DRF","permalink":"https://liangweijiang.github.io/tags/DRF/"}]},{"title":"每日一道算法之--三数之和","slug":"algorithm-15","date":"2020-02-24T09:25:51.544Z","updated":"2020-03-02T10:30:37.376Z","comments":true,"path":"2020/02/24/algorithm-15/","link":"","permalink":"https://liangweijiang.github.io/2020/02/24/algorithm-15/","excerpt":"","text":"三数之和力扣第15题：https://leetcode-cn.com/problems/3sum/给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。 注意：答案中不可以包含重复的三元组。 示例： 给定数组 nums = [-1, 0, 1, 2, -1, -4]，满足要求的三元组集合为：[ [-1, 0, 1], [-1, -1, 2]] 1. 排序 + 双指针解法题目中的要求是不能含有相同的三元组，所以在算法中我们需要去重，排序是一个很好的方法，因为排序可以让相同的数连载一起，方便判断去重。让后在通过双指针对数组一一检查，找到所有合适的三元组。 1234567891011121314151617181920212223242526272829class Solution: def threeSum(self, nums: List[int]) -&gt; List[List[int]]: # 先将nums排序 nums.sort() res = [] for i in range(len(nums) - 2): # 设置两个指针 l, r = i + 1, len(nums) - 1 if nums[i] &gt; 0 : return res # 去除重复的判断,因为nums[i -1]已经包含了nums[i]的所有组合的可能性 if i &gt; 0 and nums[i] == nums[i - 1] : continue while l &lt; r: s = nums[i] + nums[l] + nums[r] if s &lt; 0: # 如果和小于0，证明左边的数太小了，需要往后移 l += 1 # 去除重复的判断，但是前提条件为l&lt;r while l &lt; r and nums[l] == nums[l - 1]: l += 1 elif s &gt; 0: r -= 1 # 如果和大于0，证明右边的数太大了，需要往前移 while l &lt; r and nums[r] == nums[r + 1]: r -= 1 else: res.append([nums[i], nums[l], nums[r]]) l += 1 r -= 1 while l &lt; r and nums[l] == nums[l - 1]: l += 1 while l &lt; r and nums[r] == nums[r + 1]: r -= 1 return res 1.1 时间复杂度分析 时间复杂度：排序的时间复杂度为 O(NlogN), 遍历数组为O(N),双指针的遍历为O(N),所以总的时间复杂度为$$O(NlogN)+0(N)*O(N) = O(N^2)$$ 空间复杂度：没有用到额外的数据结构，所以空间复杂度为$$O(1)$$ 2.哈希索引的方法（空间换时间）参考两数之和，我们可以构建哈希表的方法使查找效率变得更高。 12345678910111213141516171819202122232425262728class Solution: def threeSum(self, nums: List[int]) -&gt; List[List[int]]: if len(nums) &lt; 3: return [] nums.sort() # 因为a+b = 0等价于a = -b target_hash = &#123;-x: i for i, x in enumerate(nums)&#125; res = [] res_hash = &#123;&#125; # 从零开始检索,到倒数第二位结束 for i, first in enumerate(nums[:-1]): if nums[i] &gt; 0: return res if i &gt; 0 and first == nums[i - 1]: continue #从第一个指针的下一位开始搜索 for j, second in enumerate(nums[i + 1:]): # 检查两数之和是否存在于哈希表target_hash中 if first + second in target_hash: target_index = target_hash[first + second] if target_index == i or target_index == i + j + 1: continue # 将找到的结果存入另一个哈希表中, 避免包含重复结果 row = sorted([first, second, nums[target_index]]) key = \",\".join([str(x) for x in row]) if key not in res_hash: res.append(row) res_hash[key] = True return res","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://liangweijiang.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"双指针","slug":"双指针","permalink":"https://liangweijiang.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"哈希表","slug":"哈希表","permalink":"https://liangweijiang.github.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"},{"name":"排序","slug":"排序","permalink":"https://liangweijiang.github.io/tags/%E6%8E%92%E5%BA%8F/"}]},{"title":"DRF源码解析4--版本控制组件的封装","slug":"DRF-04","date":"2020-02-22T14:09:24.712Z","updated":"2020-02-22T14:11:09.294Z","comments":true,"path":"2020/02/22/DRF-04/","link":"","permalink":"https://liangweijiang.github.io/2020/02/22/DRF-04/","excerpt":"","text":"一.DRF中APIView的initial()方法初始化版本信息在讲到DRF对ruquest的封装时,返回新封装的Request后,DRF执行了initial()方法对组件的初始化 12345678910111213def initial(self, request, *args, **kwargs): # 版本控制组件 version, scheme = self.determine_version(request, *args, **kwargs) # 将版本空值信息写入request中 request.version, request.versioning_scheme = version, scheme # Ensure that the incoming request is permitted # 认证组件 self.perform_authentication(request) # 权限组件 self.check_permissions(request) # 频率 self.check_throttles(request) 1.1重写determine_version()自定制版本信息12345678910 def determine_version(self, request, *args, **kwargs): \"\"\" If versioning is being used, then determine any API version for the incoming request. Returns a two-tuple of (version, versioning_scheme) \"\"\" if self.versioning_class is None: return (None, None)# self.versioning_class是drf配置默认的类,说明我们自定义版本时要重写这个方法 scheme = self.versioning_class() return (scheme.determine_version(request, *args, **kwargs), scheme) 二.rest_framework.versioning提供的版本控制方法 2.1 BaseVersioning1234567891011121314151617181920212223class BaseVersioning: # default_version(None), allowed_versions(None), version_param可以在settings中重新配置 default_version = api_settings.DEFAULT_VERSION allowed_versions = api_settings.ALLOWED_VERSIONS version_param = api_settings.VERSION_PARAM def determine_version(self, request, *args, **kwargs): # 在继承该类时要重写determine_version(方法) msg = '&#123;cls&#125;.determine_version() must be implemented.' raise NotImplementedError(msg.format( cls=self.__class__.__name__ )) def reverse(self, viewname, args=None, kwargs=None, request=None, format=None, **extra): # 和django.urls.reverse大致相同, # 但可以选择接受一个请求并返回使用请求获取基本URL的标准URL。 return _reverse(viewname, args, kwargs, request, format, **extra) def is_allowed_version(self, version): if not self.allowed_versions: return True return ((version is not None and version == self.default_version) or (version in self.allowed_versions)) 2.2 URLPathVersioning1234567891011121314151617181920212223242526272829303132333435363738class URLPathVersioning(BaseVersioning): \"\"\" To the client this is the same style as `NamespaceVersioning`. The difference is in the backend - this implementation uses Django's URL keyword arguments to determine the version. An example URL conf for two views that accept two different versions. 可以看到版本信息就在url中 urlpatterns = [ url(r'^(?P&lt;version&gt;[v1|v2]+)/users/$', users_list, name='users-list'), url(r'^(?P&lt;version&gt;[v1|v2]+)/users/(?P&lt;pk&gt;[0-9]+)/$', users_detail, name='users-detail') ] GET /1.0/something/ HTTP/1.1 Host: example.com Accept: application/json \"\"\" invalid_version_message = _('Invalid version in URL path.') def determine_version(self, request, *args, **kwargs): # self.version_param,self.default_version是父类中的属性,可以自定义 version = kwargs.get(self.version_param, self.default_version) if version is None: # 如果没有自己配置默认为DRF默认的版本信息 version = self.default_version if not self.is_allowed_version(version): raise exceptions.NotFound(self.invalid_version_message) return version def reverse(self, viewname, args=None, kwargs=None, request=None, format=None, **extra): if request.version is not None: kwargs = &#123;&#125; if (kwargs is None) else kwargs # self.version_param就是版本的key kwargs[self.version_param] = request.version return super().reverse( viewname, args, kwargs, request, format, **extra 其他的类基本配置都差不多","categories":[{"name":"django-rest-framework","slug":"django-rest-framework","permalink":"https://liangweijiang.github.io/categories/django-rest-framework/"}],"tags":[{"name":"DRF","slug":"DRF","permalink":"https://liangweijiang.github.io/tags/DRF/"}]},{"title":"DRF源码解析3--routers对路由的封装","slug":"DRF-03","date":"2020-02-20T15:15:11.102Z","updated":"2020-02-20T15:16:50.088Z","comments":true,"path":"2020/02/20/DRF-03/","link":"","permalink":"https://liangweijiang.github.io/2020/02/20/DRF-03/","excerpt":"","text":"当我们想最方便的使用drf的路由的时候,只需要用DefaultRoute实例化一个路由实例,然后注册,再讲注册后的组件加入urlpatterns即可 123456from rest_framework.routers import DefaultRouterrouter = DefaultRouter()# 其中BookModelView继承了viewsets.ModelViewSetrouter.register(r'^book', views.BookModelView)urlpatterns += router.urls 到底routers底层是怎么样实现的呢 routersDefaultRoute是routers组件里的一个类,相当于帮助我们在路由里构建好了如{‘list’:”create”}的对应关系,它继承了SimpleRouter,截取源码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102class SimpleRouter(BaseRouter): routes = [ # List route. Route( url=r'^&#123;prefix&#125;&#123;trailing_slash&#125;$', # 这里构建好了对应关系 mapping=&#123; 'get': 'list', 'post': 'create' &#125;, name='&#123;basename&#125;-list', detail=False, initkwargs=&#123;'suffix': 'List'&#125; ), def __init__(self, trailing_slash=True): self.trailing_slash = '/' if trailing_slash else '' super().__init__() def get_default_basename(self, viewset): \"\"\" If `basename` is not specified, attempt to automatically determine it from the viewset. \"\"\" queryset = getattr(viewset, 'queryset', None) assert queryset is not None, '`basename` argument not specified, and could ' \\ 'not automatically determine the name from the viewset, as ' \\ 'it does not have a `.queryset` attribute.' return queryset.model._meta.object_name.lower() def get_routes(self, viewset): # 获取对应关系 known_actions = list(flatten([route.mapping.values() for route in self.routes if isinstance(route, Route)])) # 找出viewsets里所有的方法 extra_actions = viewset.get_extra_actions() # checking action names against the known actions list # 判断路由的方法对应的viewsets的方法 not_allowed = [ action.__name__ for action in extra_actions if action.__name__ in known_actions ] if not_allowed: msg = ('Cannot use the @action decorator on the following ' 'methods, as they are existing routes: %s') raise ImproperlyConfigured(msg % ', '.join(not_allowed)) # partition detail and list actions detail_actions = [action for action in extra_actions if action.detail] list_actions = [action for action in extra_actions if not action.detail] routes = [] for route in self.routes: if isinstance(route, DynamicRoute) and route.detail: routes += [self._get_dynamic_route(route, action) for action in detail_actions] elif isinstance(route, DynamicRoute) and not route.detail: routes += [self._get_dynamic_route(route, action) for action in list_actions] else: routes.append(route) return routes def get_urls(self): \"\"\" Use the registered viewsets to generate a list of URL patterns. \"\"\" ret = [] # 这里的self.registry是父类BaseRouter的一个属性 for prefix, viewset, basename in self.registry: lookup = self.get_lookup_regex(viewset) routes = self.get_routes(viewset) # 这里是对路径进行了不同形式的封装 for route in routes: # Only actions which actually exist on the viewset will be bound mapping = self.get_method_map(viewset, route.mapping) if not mapping: continue # Build the url pattern regex = route.url.format( prefix=prefix, lookup=lookup, trailing_slash=self.trailing_slash ) if not prefix and regex[:2] == '^/': regex = '^' + regex[2:] initkwargs = route.initkwargs.copy() initkwargs.update(&#123; 'basename': basename, 'detail': route.detail, &#125;) view = viewset.as_view(mapping, **initkwargs) name = route.name.format(basename=basename) ret.append(url(regex, view, name=name)) return ret 进入BaseRouter中,截取源码如下: 1234567891011121314151617181920212223242526272829303132333435class BaseRouter: def __init__(self): # SimpleRouter的get_urls中的需要的属性 self.registry = [] def register(self, prefix, viewset, basename=None): # 如果没有basename,则self.get_default_basename()方法 # get_default_basename()方法就是报错要求basename必须有, # 从而看得出来要想使用router组件必须执行register()方法 if basename is None: basename = self.get_default_basename(viewset) self.registry.append((prefix, viewset, basename)) # invalidate the urls cache if hasattr(self, '_urls'): del self._urls def get_default_basename(self, viewset): \"\"\" If `basename` is not specified, attempt to automatically determine it from the viewset. \"\"\" raise NotImplementedError('get_default_basename must be overridden') def get_urls(self): \"\"\" Return a list of URL patterns, given the registered viewsets. \"\"\" raise NotImplementedError('get_urls must be overridden') @property def urls(self): if not hasattr(self, '_urls'): self._urls = self.get_urls() return self._urls DefaultRoute类进行了更好的优化 123456789101112131415161718192021222324252627282930313233343536373839404142class DefaultRouter(SimpleRouter): \"\"\" The default router extends the SimpleRouter, but also adds in a default API root view, and adds format suffix patterns to the URLs. \"\"\" include_root_view = True include_format_suffixes = True root_view_name = 'api-root' default_schema_renderers = None APIRootView = APIRootView APISchemaView = SchemaView SchemaGenerator = SchemaGenerator def __init__(self, *args, **kwargs): if 'root_renderers' in kwargs: self.root_renderers = kwargs.pop('root_renderers') else: self.root_renderers = list(api_settings.DEFAULT_RENDERER_CLASSES) super().__init__(*args, **kwargs) def get_api_root_view(self, api_urls=None): \"\"\" Return a basic root view. \"\"\" api_root_dict = OrderedDict() list_name = self.routes[0].name for prefix, viewset, basename in self.registry: api_root_dict[prefix] = list_name.format(basename=basename) return self.APIRootView.as_view(api_root_dict=api_root_dict) def get_urls(self): urls = super().get_urls() if self.include_root_view: view = self.get_api_root_view(api_urls=urls) root_url = url(r'^$', view, name=self.root_view_name) urls.append(root_url) if self.include_format_suffixes: urls = format_suffix_patterns(urls) return urls 最后路由组件创建了怎么样的url?","categories":[{"name":"django-rest-framework","slug":"django-rest-framework","permalink":"https://liangweijiang.github.io/categories/django-rest-framework/"}],"tags":[{"name":"DRF","slug":"DRF","permalink":"https://liangweijiang.github.io/tags/DRF/"}]},{"title":"DRF源码解析2--viewsets.ModelViewSet对视图的封装","slug":"DRF-02","date":"2020-02-19T13:47:47.427Z","updated":"2020-02-19T15:08:42.664Z","comments":true,"path":"2020/02/19/DRF-02/","link":"","permalink":"https://liangweijiang.github.io/2020/02/19/DRF-02/","excerpt":"","text":"viewsetsdrf中 viewsets 对 view 进行了更加深层的封装,在CBV编程中减少代码的冗余,截取viewsets源码如下 12345678class ModelViewSet(mixins.CreateModelMixin, mixins.RetrieveModelMixin, mixins.UpdateModelMixin, mixins.DestroyModelMixin, mixins.ListModelMixin, GenericViewSet):# 可以看到viewsets中的ModelViewSet只是继承了各种类,每一个类对应CBV的每一个方法,如CreateModelMixin则对应post方法 pass 进入GenericViewSet的源码中,不难发现,GenericViewSet这个类主要是获取我们的数据和处理数据的组件 123class GenericViewSet(ViewSetMixin, generics.GenericAPIView): # GenericViewSet同样是继承了两个类 pass 进入generics.GenericAPIView 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657class GenericAPIView(views.APIView): # queryset就是获取的ORM对象 queryset = None # serializer_class是序列化的类 serializer_class = None lookup_field = 'pk' lookup_url_kwarg = None # The filter backend classes to use for queryset filtering filter_backends = api_settings.DEFAULT_FILTER_BACKENDS # The style to use for queryset pagination. # pagination_class就是和分页组件相关的类,默认为drf配置中的组件 pagination_class = api_settings.DEFAULT_PAGINATION_CLASS def get_queryset(self): # 这里断言就是为了说明在继承这个类时,一定要有queryset属性或覆盖这个方法 assert self.queryset is not None, ( \"'%s' should either include a `queryset` attribute, \" \"or override the `get_queryset()` method.\" % self.__class__.__name__ ) # 获取ORM对象 queryset = self.queryset if isinstance(queryset, QuerySet): # Ensure queryset is re-evaluated on each request. queryset = queryset.all() return queryset def get_serializer(self, *args, **kwargs): serializer_class = self.get_serializer_class() kwargs['context'] = self.get_serializer_context() # serializer_class接收的参数可能不同 return serializer_class(*args, **kwargs) def get_serializer_class(self): # 继承这个类时,一定要有serializer_classt属性或覆盖这个方法 assert self.serializer_class is not None, ( \"'%s' should either include a `serializer_class` attribute, \" \"or override the `get_serializer_class()` method.\" % self.__class__.__name__ ) return self.serializer_class def get_serializer_context(self): return &#123; 'request': self.request, 'format': self.format_kwarg, 'view': self &#125; def filter_queryset(self, queryset): for backend in list(self.filter_backends): queryset = backend().filter_queryset(self.request, queryset, self) return queryset 接着回到ModelViewSet中,进入到mixins.CreateModelMixin的源码中 1234567891011121314151617181920class CreateModelMixin: \"\"\" Create a model instance. \"\"\" def create(self, request, *args, **kwargs): # 这里调用的就是GenericAPIView中的get_serializer serializer = self.get_serializer(data=request.data) serializer.is_valid(raise_exception=True) self.perform_create(serializer) headers = self.get_success_headers(serializer.data) return Response(serializer.data, status=status.HTTP_201_CREATED, headers=headers) def perform_create(self, serializer): serializer.save() def get_success_headers(self, data): try: return &#123;'Location': str(data[api_settings.URL_FIELD_NAME])&#125; except (TypeError, KeyError): return &#123;&#125; 现在我们只需要继承ModelViewSet,然后重写queryset和处理数据所需要的组件类如序列化的类等,但是怎么将self.post对应上self.list方法呢,GenericViewSet还继承了ViewSetMixin,看一下ViewSetMixin的源码的截取 1234567891011121314151617181920212223242526272829303132333435class ViewSetMixin: @classonlymethod # 对as_view()方法又一次封装,action表示可以接收参数了 def as_view(cls, actions=None, **initkwargs): if not actions: raise TypeError(\"The `actions` argument must be provided when \" \"calling `.as_view()` on a ViewSet. For example \" \"`.as_view(&#123;'get': 'list'&#125;)`\") def view(request, *args, **kwargs): self = cls(**initkwargs) # We also store the mapping of request methods to actions, # so that we can later set the action attribute. # eg. `self.action = 'list'` on an incoming GET request. self.action_map = actions # Bind methods to actions # This is the bit that's different to a standard view # method, action退出action为一个字典,&#123;'get':'list'&#125; for method, action in actions.items(): # handler为实例中的各个方法 handler = getattr(self, action) # 这里setattr相当于metmod == handler setattr(self, method, handler) if hasattr(self, 'get') and not hasattr(self, 'head'): self.head = self.get self.request = request self.args = args self.kwargs = kwargs # And continue as usual return self.dispatch(request, *args, **kwargs) return csrf_exempt(view) 奉献一张图来看下我们的继承顺序","categories":[{"name":"django-rest-framework","slug":"django-rest-framework","permalink":"https://liangweijiang.github.io/categories/django-rest-framework/"}],"tags":[{"name":"DRF","slug":"DRF","permalink":"https://liangweijiang.github.io/tags/DRF/"}]},{"title":"DRF源码解析1--APIView对request的重新封装","slug":"DRF-01","date":"2020-02-19T08:58:37.586Z","updated":"2020-02-19T10:08:43.094Z","comments":true,"path":"2020/02/19/DRF-01/","link":"","permalink":"https://liangweijiang.github.io/2020/02/19/DRF-01/","excerpt":"","text":"截取APIView12345678910111213141516171819202122232425262728293031323334353637383940414243444546@classmethodclass APIView(View): def as_view(cls, **initkwargs): if isinstance(getattr(cls, 'queryset', None), models.query.QuerySet): def force_evaluation(): raise RuntimeError( 'Do not evaluate the `.queryset` attribute directly, ' 'as the result will be cached and reused between requests. ' 'Use `.all()` or call `.get_queryset()` instead.' ) cls.queryset._fetch_all = force_evaluation # 继承了django中View类的的as_view()方法,然后重写了dispatch方法 view = super().as_view(**initkwargs) view.cls = cls view.initkwargs = initkwargs return csrf_exempt(view) def dispatch(self, request, *args, **kwargs): self.args = args self.kwargs = kwargs # 在传入request是,apiview对request进行了一次包装 request = self.initialize_request(request, *args, **kwargs) # 此时self.request是initialize_request方法返回的Request self.request = request self.headers = self.default_response_headers # deprecate? try: # 相比于View类的dispatch方法,Apiview在这里进行了一次初始化的方法 self.initial(request, *args, **kwargs) # Get the appropriate handler method if request.method.lower() in self.http_method_names: handler = getattr(self, request.method.lower(), self.http_method_not_allowed) else: handler = self.http_method_not_allowed response = handler(request, *args, **kwargs) except Exception as exc: response = self.handle_exception(exc) self.response = self.finalize_response(request, response, *args, **kwargs) return self.response 进入self.initalize_request()12345678910def initialize_request(self, request, *args, **kwargs): parser_context = self.get_parser_context(request) # 可以看到, request已经被封装成Request返回,而request则被封装成Request的一个属性 return Request( request, parsers=self.get_parsers(), authenticators=self.get_authenticators(), negotiator=self.get_content_negotiator(), parser_context=parser_context ) 截取Ruquest123456789101112131415161718192021222324252627282930class Request: def __init__(self, request, parsers=None, authenticators=None, negotiator=None, parser_context=None): assert isinstance(request, HttpRequest), ( 'The `request` argument must be an instance of ' '`django.http.HttpRequest`, not `&#123;&#125;.&#123;&#125;`.' .format(request.__class__.__module__, request.__class__.__name__) ) # request被封装了私有属性 self._request = request @property def content_type(self): meta = self._request.META # 封装了content_type方法获取传输类型 return meta.get('CONTENT_TYPE', meta.get('HTTP_CONTENT_TYPE', '')) @property def query_params(self): \"\"\" More semantically correct name for request.GET. \"\"\" # django的view中的request.Get属性封装成了query_params属性 return self._request.GET @property def data(self): if not _hasattr(self, '_full_data'): self._load_data_and_files() # django的view中的request.Post属性封装成了data属性 return self._full_data 我们可以看出~CBV在内部做了一个分发,本质和FBV是一样的。 以后做接口开发的时候，就要用CBV，学习了restful规范，现在就很容易理解我们为什么用CBV了。","categories":[{"name":"django-rest-framework","slug":"django-rest-framework","permalink":"https://liangweijiang.github.io/categories/django-rest-framework/"}],"tags":[{"name":"DRF","slug":"DRF","permalink":"https://liangweijiang.github.io/tags/DRF/"}]}]}